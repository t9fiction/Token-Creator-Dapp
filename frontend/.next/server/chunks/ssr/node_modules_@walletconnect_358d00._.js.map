{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/environment/node_modules/tslib/tslib.es6.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/node_modules/tslib/tslib.es6.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 773, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 779, "column": 0}, "map": {"version":3,"sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/node_modules/tslib/tslib.es6.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;8EAa8E,GAC9E,2BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;AAE3B,IAAI,gBAAgB,SAAS,CAAC,EAAE,CAAC;IAC7B,gBAAgB,OAAO,cAAc,IAChC,CAAA;QAAE,WAAW,EAAE;IAAC,CAAA,aAAa,SAAS,SAAU,CAAC,EAAE,CAAC;QAAI,EAAE,SAAS,GAAG;IAAG,KAC1E,SAAU,CAAC,EAAE,CAAC;QAAI,IAAK,IAAI,KAAK,EAAG,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;IAAE;IAC7E,OAAO,cAAc,GAAG;AAC5B;AAEO,SAAS,UAAU,CAAC,EAAE,CAAC;IAC1B,cAAc,GAAG;IACjB,SAAS;QAAO,IAAI,CAAC,WAAW,GAAG;IAAG;IACtC,EAAE,SAAS,GAAG,MAAM,OAAO,OAAO,MAAM,CAAC,KAAK,CAAC,GAAG,SAAS,GAAG,EAAE,SAAS,EAAE,IAAI,IAAI;AACvF;AAEO,IAAI,WAAW;IAClB,WAAW,OAAO,MAAM,IAAI,SAAS,SAAS,CAAC;QAC3C,IAAK,IAAI,GAAG,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAI,GAAG,IAAK;YACjD,IAAI,SAAS,CAAC,EAAE;YAChB,IAAK,IAAI,KAAK,EAAG,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;QAChF;QACA,OAAO;IACX;IACA,OAAO,SAAS,KAAK,CAAC,IAAI,EAAE;AAChC;AAEO,SAAS,OAAO,CAAC,EAAE,CAAC;IACvB,IAAI,IAAI,CAAC;IACT,IAAK,IAAI,KAAK,EAAG,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,MAAM,EAAE,OAAO,CAAC,KAAK,GAC9E,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;IACf,IAAI,KAAK,QAAQ,OAAO,OAAO,qBAAqB,KAAK,YACrD,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,qBAAqB,CAAC,IAAI,IAAI,EAAE,MAAM,EAAE,IAAK;QACpE,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,IAAI,KAAK,OAAO,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GACzE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACzB;IACJ,OAAO;AACX;AAEO,SAAS,WAAW,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI;IACpD,IAAI,IAAI,UAAU,MAAM,EAAE,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,wBAAwB,CAAC,QAAQ,OAAO,MAAM;IAC3H,IAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,QAAQ,KAAK,YAAY,IAAI,QAAQ,QAAQ,CAAC,YAAY,QAAQ,KAAK;SACpH,IAAK,IAAI,IAAI,WAAW,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK,IAAI,IAAI,UAAU,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,IAAI,EAAE,KAAK,IAAI,IAAI,EAAE,QAAQ,KAAK,KAAK,EAAE,QAAQ,IAAI,KAAK;IAChJ,OAAO,IAAI,KAAK,KAAK,OAAO,cAAc,CAAC,QAAQ,KAAK,IAAI;AAChE;AAEO,SAAS,QAAQ,UAAU,EAAE,SAAS;IACzC,OAAO,SAAU,MAAM,EAAE,GAAG;QAAI,UAAU,QAAQ,KAAK;IAAa;AACxE;AAEO,SAAS,WAAW,WAAW,EAAE,aAAa;IACjD,IAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,QAAQ,KAAK,YAAY,OAAO,QAAQ,QAAQ,CAAC,aAAa;AACpH;AAEO,SAAS,UAAU,OAAO,EAAE,UAAU,EAAE,CAAC,EAAE,SAAS;IACvD,SAAS,MAAM,KAAK;QAAI,OAAO,iBAAiB,IAAI,QAAQ,IAAI,EAAE,SAAU,OAAO;YAAI,QAAQ;QAAQ;IAAI;IAC3G,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,EAAE,SAAU,OAAO,EAAE,MAAM;QACrD,SAAS,UAAU,KAAK;YAAI,IAAI;gBAAE,KAAK,UAAU,IAAI,CAAC;YAAS,EAAE,OAAO,GAAG;gBAAE,OAAO;YAAI;QAAE;QAC1F,SAAS,SAAS,KAAK;YAAI,IAAI;gBAAE,KAAK,SAAS,CAAC,QAAQ,CAAC;YAAS,EAAE,OAAO,GAAG;gBAAE,OAAO;YAAI;QAAE;QAC7F,SAAS,KAAK,MAAM;YAAI,OAAO,IAAI,GAAG,QAAQ,OAAO,KAAK,IAAI,MAAM,OAAO,KAAK,EAAE,IAAI,CAAC,WAAW;QAAW;QAC7G,KAAK,CAAC,YAAY,UAAU,KAAK,CAAC,SAAS,cAAc,EAAE,CAAC,EAAE,IAAI;IACtE;AACJ;AAEO,SAAS,YAAY,OAAO,EAAE,IAAI;IACrC,IAAI,IAAI;QAAE,OAAO;QAAG,MAAM;YAAa,IAAI,CAAC,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,CAAC,EAAE;YAAE,OAAO,CAAC,CAAC,EAAE;QAAE;QAAG,MAAM,EAAE;QAAE,KAAK,EAAE;IAAC,GAAG,GAAG,GAAG,GAAG;IAC/G,OAAO,IAAI;QAAE,MAAM,KAAK;QAAI,SAAS,KAAK;QAAI,UAAU,KAAK;IAAG,GAAG,OAAO,WAAW,cAAc,CAAC,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAG;QAAa,OAAO,IAAI;IAAE,CAAC,GAAG;;IACvJ,SAAS,KAAK,CAAC;QAAI,OAAO,SAAU,CAAC;YAAI,OAAO,KAAK;gBAAC;gBAAG;aAAE;QAAG;IAAG;IACjE,SAAS,KAAK,EAAE;QACZ,IAAI,GAAG,MAAM,IAAI,UAAU;QAC3B,MAAO,EAAG,IAAI;YACV,IAAI,IAAI,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,SAAS,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,KAAK,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO;YAC3J,IAAI,IAAI,GAAG,GAAG,KAAK;gBAAC,EAAE,CAAC,EAAE,GAAG;gBAAG,EAAE,KAAK;aAAC;YACvC,OAAQ,EAAE,CAAC,EAAE;gBACT,KAAK;gBAAG,KAAK;oBAAG,IAAI;oBAAI;gBACxB,KAAK;oBAAG,EAAE,KAAK;oBAAI,OAAO;wBAAE,OAAO,EAAE,CAAC,EAAE;wBAAE,MAAM;oBAAM;gBACtD,KAAK;oBAAG,EAAE,KAAK;oBAAI,IAAI,EAAE,CAAC,EAAE;oBAAE,KAAK;wBAAC;qBAAE;oBAAE;gBACxC,KAAK;oBAAG,KAAK,EAAE,GAAG,CAAC,GAAG;oBAAI,EAAE,IAAI,CAAC,GAAG;oBAAI;gBACxC;oBACI,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,GAAG,KAAK,CAAC,CAAC,EAAE,MAAM,GAAG,EAAE,KAAK,CAAC,EAAE,CAAC,EAAE,KAAK,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,GAAG;wBAAE,IAAI;wBAAG;oBAAU;oBAC3G,IAAI,EAAE,CAAC,EAAE,KAAK,KAAK,CAAC,CAAC,KAAM,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,AAAC,GAAG;wBAAE,EAAE,KAAK,GAAG,EAAE,CAAC,EAAE;wBAAE;oBAAO;oBACrF,IAAI,EAAE,CAAC,EAAE,KAAK,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE,EAAE;wBAAE,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE;wBAAE,IAAI;wBAAI;oBAAO;oBACpE,IAAI,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE,EAAE;wBAAE,EAAE,KAAK,GAAG,CAAC,CAAC,EAAE;wBAAE,EAAE,GAAG,CAAC,IAAI,CAAC;wBAAK;oBAAO;oBAClE,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,GAAG;oBACnB,EAAE,IAAI,CAAC,GAAG;oBAAI;YACtB;YACA,KAAK,KAAK,IAAI,CAAC,SAAS;QAC5B,EAAE,OAAO,GAAG;YAAE,KAAK;gBAAC;gBAAG;aAAE;YAAE,IAAI;QAAG,SAAU;YAAE,IAAI,IAAI;QAAG;QACzD,IAAI,EAAE,CAAC,EAAE,GAAG,GAAG,MAAM,EAAE,CAAC,EAAE;QAAE,OAAO;YAAE,OAAO,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,KAAK;YAAG,MAAM;QAAK;IACnF;AACJ;AAEO,SAAS,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IACvC,IAAI,OAAO,WAAW,KAAK;IAC3B,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;AAChB;AAEO,SAAS,aAAa,CAAC,EAAE,OAAO;IACnC,IAAK,IAAI,KAAK,EAAG,IAAI,MAAM,aAAa,CAAC,QAAQ,cAAc,CAAC,IAAI,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AACzF;AAEO,SAAS,SAAS,CAAC;IACtB,IAAI,IAAI,OAAO,WAAW,cAAc,OAAO,QAAQ,EAAE,IAAI,KAAK,CAAC,CAAC,EAAE,EAAE,IAAI;IAC5E,IAAI,GAAG,OAAO,EAAE,IAAI,CAAC;IACrB,IAAI,KAAK,OAAO,EAAE,MAAM,KAAK,UAAU,OAAO;QAC1C,MAAM;YACF,IAAI,KAAK,KAAK,EAAE,MAAM,EAAE,IAAI,KAAK;YACjC,OAAO;gBAAE,OAAO,KAAK,CAAC,CAAC,IAAI;gBAAE,MAAM,CAAC;YAAE;QAC1C;IACJ;IACA,MAAM,IAAI,UAAU,IAAI,4BAA4B;AACxD;AAEO,SAAS,OAAO,CAAC,EAAE,CAAC;IACvB,IAAI,IAAI,OAAO,WAAW,cAAc,CAAC,CAAC,OAAO,QAAQ,CAAC;IAC1D,IAAI,CAAC,GAAG,OAAO;IACf,IAAI,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,KAAK,EAAE,EAAE;IAC/B,IAAI;QACA,MAAO,CAAC,MAAM,KAAK,KAAK,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE,IAAI,CAAE,GAAG,IAAI,CAAC,EAAE,KAAK;IAC7E,EACA,OAAO,OAAO;QAAE,IAAI;YAAE,OAAO;QAAM;IAAG,SAC9B;QACJ,IAAI;YACA,IAAI,KAAK,CAAC,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,SAAS,GAAG,EAAE,IAAI,CAAC;QAClD,SACQ;YAAE,IAAI,GAAG,MAAM,EAAE,KAAK;QAAE;IACpC;IACA,OAAO;AACX;AAEO,SAAS;IACZ,IAAK,IAAI,KAAK,EAAE,EAAE,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAC3C,KAAK,GAAG,MAAM,CAAC,OAAO,SAAS,CAAC,EAAE;IACtC,OAAO;AACX;AAEO,SAAS;IACZ,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,UAAU,MAAM,EAAE,IAAI,IAAI,IAAK,KAAK,SAAS,CAAC,EAAE,CAAC,MAAM;IACnF,IAAK,IAAI,IAAI,MAAM,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IACzC,IAAK,IAAI,IAAI,SAAS,CAAC,EAAE,EAAE,IAAI,GAAG,KAAK,EAAE,MAAM,EAAE,IAAI,IAAI,KAAK,IAC1D,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;IACnB,OAAO;AACX;;AAEO,SAAS,QAAQ,CAAC;IACrB,OAAO,IAAI,YAAY,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,IAAI,IAAI,IAAI,QAAQ;AACtE;AAEO,SAAS,iBAAiB,OAAO,EAAE,UAAU,EAAE,SAAS;IAC3D,IAAI,CAAC,OAAO,aAAa,EAAE,MAAM,IAAI,UAAU;IAC/C,IAAI,IAAI,UAAU,KAAK,CAAC,SAAS,cAAc,EAAE,GAAG,GAAG,IAAI,EAAE;IAC7D,OAAO,IAAI,CAAC,GAAG,KAAK,SAAS,KAAK,UAAU,KAAK,WAAW,CAAC,CAAC,OAAO,aAAa,CAAC,GAAG;QAAc,OAAO,IAAI;IAAE,GAAG;;IACpH,SAAS,KAAK,CAAC;QAAI,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,SAAU,CAAC;YAAI,OAAO,IAAI,QAAQ,SAAU,CAAC,EAAE,CAAC;gBAAI,EAAE,IAAI,CAAC;oBAAC;oBAAG;oBAAG;oBAAG;iBAAE,IAAI,KAAK,OAAO,GAAG;YAAI;QAAI;IAAG;IACzI,SAAS,OAAO,CAAC,EAAE,CAAC;QAAI,IAAI;YAAE,KAAK,CAAC,CAAC,EAAE,CAAC;QAAK,EAAE,OAAO,GAAG;YAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;QAAI;IAAE;IACjF,SAAS,KAAK,CAAC;QAAI,EAAE,KAAK,YAAY,UAAU,QAAQ,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,UAAU,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;IAAI;IACvH,SAAS,QAAQ,KAAK;QAAI,OAAO,QAAQ;IAAQ;IACjD,SAAS,OAAO,KAAK;QAAI,OAAO,SAAS;IAAQ;IACjD,SAAS,OAAO,CAAC,EAAE,CAAC;QAAI,IAAI,EAAE,IAAI,EAAE,KAAK,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE;IAAG;AACrF;AAEO,SAAS,iBAAiB,CAAC;IAC9B,IAAI,GAAG;IACP,OAAO,IAAI,CAAC,GAAG,KAAK,SAAS,KAAK,SAAS,SAAU,CAAC;QAAI,MAAM;IAAG,IAAI,KAAK,WAAW,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAG;QAAc,OAAO,IAAI;IAAE,GAAG;;IAC1I,SAAS,KAAK,CAAC,EAAE,CAAC;QAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,SAAU,CAAC;YAAI,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI;gBAAE,OAAO,QAAQ,CAAC,CAAC,EAAE,CAAC;gBAAK,MAAM,MAAM;YAAS,IAAI,IAAI,EAAE,KAAK;QAAG,IAAI;IAAG;AAClJ;AAEO,SAAS,cAAc,CAAC;IAC3B,IAAI,CAAC,OAAO,aAAa,EAAE,MAAM,IAAI,UAAU;IAC/C,IAAI,IAAI,CAAC,CAAC,OAAO,aAAa,CAAC,EAAE;IACjC,OAAO,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,OAAO,aAAa,aAAa,SAAS,KAAK,CAAC,CAAC,OAAO,QAAQ,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,SAAS,KAAK,UAAU,KAAK,WAAW,CAAC,CAAC,OAAO,aAAa,CAAC,GAAG;QAAc,OAAO,IAAI;IAAE,GAAG,CAAC;;IAC/M,SAAS,KAAK,CAAC;QAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,IAAI,SAAU,CAAC;YAAI,OAAO,IAAI,QAAQ,SAAU,OAAO,EAAE,MAAM;gBAAI,IAAI,CAAC,CAAC,EAAE,CAAC,IAAI,OAAO,SAAS,QAAQ,EAAE,IAAI,EAAE,EAAE,KAAK;YAAG;QAAI;IAAG;IAC/J,SAAS,OAAO,OAAO,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC;QAAI,QAAQ,OAAO,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;YAAI,QAAQ;gBAAE,OAAO;gBAAG,MAAM;YAAE;QAAI,GAAG;IAAS;AAC/H;AAEO,SAAS,qBAAqB,MAAM,EAAE,GAAG;IAC5C,IAAI,OAAO,cAAc,EAAE;QAAE,OAAO,cAAc,CAAC,QAAQ,OAAO;YAAE,OAAO;QAAI;IAAI,OAAO;QAAE,OAAO,GAAG,GAAG;IAAK;IAC9G,OAAO;AACX;;AAEO,SAAS,aAAa,GAAG;IAC5B,IAAI,OAAO,IAAI,UAAU,EAAE,OAAO;IAClC,IAAI,SAAS,CAAC;IACd,IAAI,OAAO,MAAM;QAAA,IAAK,IAAI,KAAK,IAAK,IAAI,OAAO,cAAc,CAAC,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE;IAAA;IAC9F,OAAO,OAAO,GAAG;IACjB,OAAO;AACX;AAEO,SAAS,gBAAgB,GAAG;IAC/B,OAAO,AAAC,OAAO,IAAI,UAAU,GAAI,MAAM;QAAE,SAAS;IAAI;AAC1D;AAEO,SAAS,uBAAuB,QAAQ,EAAE,UAAU;IACvD,IAAI,CAAC,WAAW,GAAG,CAAC,WAAW;QAC3B,MAAM,IAAI,UAAU;IACxB;IACA,OAAO,WAAW,GAAG,CAAC;AAC1B;AAEO,SAAS,uBAAuB,QAAQ,EAAE,UAAU,EAAE,KAAK;IAC9D,IAAI,CAAC,WAAW,GAAG,CAAC,WAAW;QAC3B,MAAM,IAAI,UAAU;IACxB;IACA,WAAW,GAAG,CAAC,UAAU;IACzB,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1165, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/safe-json/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/safe-json/src/index.ts"],"names":[],"mappings":";;;;AAQA,MAAM,aAAa,IAAG,IAAI,CAAC,EAAE,AAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAC9B,CADgC,MACzB,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAC3D,CAAC;AASJ,MAAM,SAAS,IAAG,IAAI,CAAC,EAAE;IAMvB,MAAM,uBAAuB,GAAG,oQAAoQ,CAAC;IACrS,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;IAE5E,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC7C,MAAM,oBAAoB,GACxB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAErD,IAAI,oBAAoB,EACtB,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEtD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEI,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;KACzB,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACxE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1198, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/logger/src/constants.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/logger/src/linkedList.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/logger/src/baseChunkLogger.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/logger/src/clientChunkLogger.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/logger/src/serverChunkLogger.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/logger/src/utils.ts"],"sourcesContent":["export const PINO_LOGGER_DEFAULTS = {\n  level: \"info\",\n};\n\nexport const PINO_CUSTOM_CONTEXT_KEY = \"custom_context\";\n\nexport const MAX_LOG_SIZE_IN_BYTES_DEFAULT = 1000 * 1024; // 1MB\n","class LogListNode {\n  private nodeValue: string;\n  private sizeInBytes: number;\n  public next: LogListNode | null;\n\n  constructor(value: string) {\n    this.nodeValue = value;\n    this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length;\n    this.next = null;\n  }\n\n  public get value() {\n    return this.nodeValue;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n}\n\nexport default class LogLinkedList {\n  private lengthInNodes: number;\n  private sizeInBytes: number;\n  private head: LogListNode | null;\n  private tail: LogListNode | null;\n  private maxSizeInBytes: number;\n\n  constructor(maxSizeInBytes: number) {\n    this.head = null;\n    this.tail = null;\n    this.lengthInNodes = 0;\n    this.maxSizeInBytes = maxSizeInBytes;\n    this.sizeInBytes = 0;\n  }\n\n  public append(value: string): void {\n    const newNode = new LogListNode(value);\n\n    if (newNode.size > this.maxSizeInBytes) {\n      throw new Error(\n        `[LinkedList] Value too big to insert into list: ${value} with size ${newNode.size}`,\n      );\n    }\n\n    while (this.size + newNode.size > this.maxSizeInBytes) {\n      this.shift();\n    }\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      if (this.tail) {\n        this.tail.next = newNode;\n      }\n      this.tail = newNode;\n    }\n    this.lengthInNodes++;\n    this.sizeInBytes += newNode.size;\n  }\n\n  public shift(): void {\n    if (!this.head) {\n      return;\n    }\n\n    const removedNode = this.head;\n    this.head = this.head.next;\n\n    if (!this.head) {\n      this.tail = null;\n    }\n\n    this.lengthInNodes--;\n    this.sizeInBytes -= removedNode.size;\n  }\n\n  public toArray(): string[] {\n    const array: string[] = [];\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      array.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return array;\n  }\n\n  public get length() {\n    return this.lengthInNodes;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n\n  public toOrderedArray() {\n    return Array.from(this);\n  }\n\n  [Symbol.iterator](): Iterator<string> {\n    let node = this.head;\n\n    const next = (): IteratorResult<string> => {\n      if (!node) {\n        return { done: true, value: null };\n      }\n\n      const value = node.value;\n      node = node.next;\n\n      return { done: false, value };\n    };\n\n    return { next };\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport { levels } from \"pino\";\nimport LinkedList from \"./linkedList\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nexport default class BaseChunkLogger {\n  private logs: LinkedList;\n  private level: LoggerOptions[\"level\"];\n  private levelValue: number;\n\n  private MAX_LOG_SIZE_IN_BYTES: number;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.level = level ?? \"error\";\n    this.levelValue = levels.values[this.level];\n\n    this.MAX_LOG_SIZE_IN_BYTES = MAX_LOG_SIZE_IN_BYTES;\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public forwardToConsole(chunk: any, level: number) {\n    if (level === levels.values.error) {\n      // eslint-disable-next-line no-console\n      console.error(chunk);\n    } else if (level === levels.values.warn) {\n      // eslint-disable-next-line no-console\n      console.warn(chunk);\n    } else if (level === levels.values.debug) {\n      // eslint-disable-next-line no-console\n      console.debug(chunk);\n    } else if (level === levels.values.trace) {\n      // eslint-disable-next-line no-console\n      console.trace(chunk);\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(chunk);\n    }\n  }\n\n  public appendToLogs(chunk: any) {\n    this.logs.append(\n      safeJsonStringify({\n        timestamp: new Date().toISOString(),\n        log: chunk,\n      }),\n    );\n\n    // Based on https://github.com/pinojs/pino/blob/master/lib/constants.js\n    const level = typeof chunk === \"string\" ? JSON.parse(chunk).level : chunk.level;\n    if (level >= this.levelValue) {\n      this.forwardToConsole(chunk, level);\n    }\n  }\n\n  public getLogs() {\n    return this.logs;\n  }\n\n  public clearLogs() {\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public getLogArray() {\n    return Array.from(this.logs);\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    const logArray = this.getLogArray();\n    logArray.push(safeJsonStringify({ extraMetadata }));\n    const blob = new Blob(logArray, { type: \"application/json\" });\n    return blob;\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ClientChunkLogger {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n\n  public downloadLogsBlobInBrowser(extraMetadata: Record<string, string>) {\n    const url = URL.createObjectURL(this.logsToBlob(extraMetadata));\n    const anchor = document.createElement(\"a\");\n    anchor.href = url;\n    anchor.download = `walletconnect-logs-${new Date().toISOString()}.txt`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor);\n    URL.revokeObjectURL(url);\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { DestinationStream, LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ServerChunkLogger implements DestinationStream {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n}\n","import pino, { Logger, LoggerOptions } from \"pino\";\nimport { PINO_CUSTOM_CONTEXT_KEY, PINO_LOGGER_DEFAULTS } from \"./constants\";\nimport ClientChunkLogger from \"./clientChunkLogger\";\nimport ServerChunkLogger from \"./serverChunkLogger\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport interface ChunkLoggerController {\n  logsToBlob: BaseChunkLogger[\"logsToBlob\"];\n  getLogArray: () => string[];\n  clearLogs: () => void;\n  downloadLogsBlobInBrowser?: ClientChunkLogger[\"downloadLogsBlobInBrowser\"];\n}\n\nexport function getDefaultLoggerOptions(opts?: LoggerOptions): LoggerOptions {\n  return {\n    ...opts,\n    level: opts?.level || PINO_LOGGER_DEFAULTS.level,\n  };\n}\n\nexport function getBrowserLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  return (logger as any)[customContextKey] || \"\";\n}\n\nexport function setBrowserLoggerContext(\n  logger: Logger,\n  context: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  (logger as any)[customContextKey] = context;\n  return logger;\n}\n\nexport function getLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  let context = \"\";\n  // logger.bindings is undefined in browser\n  if (typeof logger.bindings === \"undefined\") {\n    context = getBrowserLoggerContext(logger, customContextKey);\n  } else {\n    context = logger.bindings().context || \"\";\n  }\n  return context;\n}\n\nexport function formatChildLoggerContext(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  const parentContext = getLoggerContext(logger, customContextKey);\n  const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;\n  return context;\n}\n\nexport function generateChildLogger(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  const context = formatChildLoggerContext(logger, childContext, customContextKey);\n  const child = logger.child({ context });\n  return setBrowserLoggerContext(child, context, customContextKey);\n}\n\nexport function generateClientLogger(params: { opts?: LoggerOptions; maxSizeInBytes?: number }): {\n  logger: Logger<any>;\n  chunkLoggerController: ClientChunkLogger;\n} {\n  const clientLogger = new ClientChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino({\n    ...params.opts,\n    level: \"trace\",\n    browser: {\n      ...params.opts?.browser,\n      write: (obj) => clientLogger.write(obj),\n    },\n  });\n\n  return { logger, chunkLoggerController: clientLogger };\n}\n\nexport function generateServerLogger(params: { maxSizeInBytes?: number; opts?: LoggerOptions }): {\n  logger: Logger<any>;\n  chunkLoggerController: ServerChunkLogger;\n} {\n  const serverLogger = new ServerChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino(\n    {\n      ...params.opts,\n      level: \"trace\",\n    },\n    serverLogger,\n  );\n\n  return { logger, chunkLoggerController: serverLogger };\n}\n\nexport function generatePlatformLogger(params: {\n  maxSizeInBytes?: number;\n  opts?: LoggerOptions;\n  loggerOverride?: string | Logger<any>;\n}): {\n  logger: Logger<any>;\n  chunkLoggerController: ChunkLoggerController | null;\n} {\n  if (typeof params.loggerOverride !== \"undefined\" && typeof params.loggerOverride !== \"string\") {\n    return {\n      logger: params.loggerOverride,\n      chunkLoggerController: null,\n    };\n  }\n\n  if (typeof window !== \"undefined\") {\n    return generateClientLogger(params);\n  } else {\n    return generateServerLogger(params);\n  }\n}\n"],"names":["LogListNode","value","LogLinkedList","maxSizeInBytes","newNode","removedNode","array","currentNode","node","BaseChunkLogger","level","MAX_LOG_SIZE_IN_BYTES","MAX_LOG_SIZE_IN_BYTES_DEFAULT","levels","LinkedList","chunk","safeJsonStringify","extraMetadata","logArray","ClientChunkLogger","url","anchor","ServerChunkLogger","opts","__spreadProps","__spreadValues","PINO_LOGGER_DEFAULTS","logger","customContextKey","PINO_CUSTOM_CONTEXT_KEY","context","childContext","parentContext","child","params","_a","_b","clientLogger","pino","obj","serverLogger"],"mappings":"","ignoreList":[0,1,2,3,4,5]}},
    {"offset": {"line": 1421, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1437, "column": 0}, "map": {"version":3,"file":"constants.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/constants.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/constants.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,WAAW,GAAG,aAAa,CAAC;AAClC,MAAM,eAAe,GAAG,iBAAiB,CAAC;AAC1C,MAAM,gBAAgB,GAAG,kBAAkB,CAAC;AAC5C,MAAM,cAAc,GAAG,gBAAgB,CAAC;AACxC,MAAM,cAAc,GAAG,gBAAgB,CAAC;AACxC,MAAM,YAAY,GAAG,cAAc,CAAC;AAEpC,MAAM,oBAAoB,GAAG;IAAC,CAAC,KAAK;IAAE,CAAC,KAAK;IAAE,CAAC,KAAK;IAAE,CAAC,KAAK;IAAE,CAAC,KAAK;CAAC,CAAC;AACtE,MAAM,uBAAuB,GAAG;IAAC,CAAC,KAAK;IAAE,CAAC,KAAK;CAAC,CAAC;AAEjD,MAAM,kBAAkB,GAAG;IAChC,CAAC,WAAW,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,aAAa;IAAA,CAAE;IACvD,CAAC,eAAe,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,iBAAiB;IAAA,CAAE;IAC/D,CAAC,gBAAgB,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,kBAAkB;IAAA,CAAE;IACjE,CAAC,cAAc,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,gBAAgB;IAAA,CAAE;IAC7D,CAAC,cAAc,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,gBAAgB;IAAA,CAAE;IAC7D,CAAC,YAAY,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,cAAc;IAAA,CAAE;CAC1D,CAAC;AAEK,MAAM,aAAa,GAAG,YAAY,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1493, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1499, "column": 0}, "map": {"version":3,"file":"error.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/error.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/error.ts"],"names":[],"mappings":";;;;;;;;;AACA,OAAO,EACL,uBAAuB,EACvB,oBAAoB,EACpB,kBAAkB,EAClB,aAAa,GACd,MAAM,aAAa,CAAC;;AAGf,SAAU,iBAAiB,CAAC,IAAY;IAC5C,OAAO,IAAI,oLAAI,0BAAuB,CAAC,CAAC,CAAC,IAAI,IAAI,oLAAI,0BAAuB,CAAC,CAAC,CAAC,CAAC;AAClF,CAAC;AAEK,SAAU,mBAAmB,CAAC,IAAY;IAC9C,uLAAO,uBAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC7C,CAAC;AAEK,SAAU,gBAAgB,CAAC,IAAY;IAC3C,OAAO,OAAO,IAAI,KAAK,QAAQ,CAAC;AAClC,CAAC;AAEK,SAAU,QAAQ,CAAC,IAAY;IACnC,IAAI,CAAC,MAAM,CAAC,IAAI,iLAAC,qBAAkB,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;QACnD,uLAAO,qBAAkB,iLAAC,gBAAa,CAAC,CAAC;KAC1C;IACD,uLAAO,qBAAkB,CAAC,IAAI,CAAC,CAAC;AAClC,CAAC;AAEK,SAAU,cAAc,CAAC,IAAY;IACzC,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,iLAAC,qBAAkB,CAAC,CAAC,IAAI,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IAC3E,IAAI,CAAC,KAAK,EAAE;QACV,uLAAO,qBAAkB,iLAAC,gBAAa,CAAC,CAAC;KAC1C;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAEK,SAAU,oBAAoB,CAAC,QAAsB;IACzD,IAAI,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;QAC9C,OAAO;YAAE,KAAK,EAAE,KAAK;YAAE,KAAK,EAAE,iCAAiC;QAAA,CAAE,CAAC;KACnE;IACD,IAAI,OAAO,QAAQ,CAAC,KAAK,CAAC,OAAO,KAAK,WAAW,EAAE;QACjD,OAAO;YAAE,KAAK,EAAE,KAAK;YAAE,KAAK,EAAE,oCAAoC;QAAA,CAAE,CAAC;KACtE;IACD,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC1C,OAAO;YACL,KAAK,EAAE,KAAK;YACZ,KAAK,EAAE,CAAA,sCAAA,EAAyC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;SACtE,CAAC;KACH;IACD,IAAI,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC5C,MAAM,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClD,IACE,KAAK,CAAC,OAAO,qLAAK,qBAAkB,iLAAC,gBAAa,CAAC,CAAC,OAAO,IAC3D,QAAQ,CAAC,KAAK,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,EACxC;YACA,OAAO;gBACL,KAAK,EAAE,KAAK;gBACZ,KAAK,EAAE,CAAA,yCAAA,EAA4C,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;aACzE,CAAC;SACH;KACF;IACD,OAAO;QAAE,KAAK,EAAE,IAAI;IAAA,CAAE,CAAC;AACzB,CAAC;AAEK,SAAU,oBAAoB,CAAC,CAAQ,EAAE,GAAW,EAAE,IAAY;IACtE,OAAO,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,sBAAsB,CAAC,GAC5F,IAAI,KAAK,CAAC,CAAA,YAAA,EAAe,IAAI,CAAA,YAAA,EAAe,GAAG,EAAE,CAAC,GAClD,CAAC,CAAC;AACR,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1567, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1573, "column": 0}, "map": {"version":3,"file":"env.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/env.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/env.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;;AAG7C,MAAM,QAAQ,0KAAG,SAAM,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1581, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"file":"format.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/format.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/format.ts"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE,mBAAmB,EAAqB,MAAM,SAAS,CAAC;AAC3F,OAAO,EAAE,cAAc,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;;;AAGrD,SAAU,SAAS,CAAC,OAAO,GAAG,CAAC;IACnC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;IAChD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;IAChE,OAAO,IAAI,GAAG,KAAK,CAAC;AACtB,CAAC;AAEK,SAAU,cAAc,CAAC,OAAO,GAAG,CAAC;IACxC,OAAO,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;AACpC,CAAC;AAEK,SAAU,oBAAoB,CAClC,MAAc,EACd,MAAS,EACT,EAAW;IAEX,OAAO;QACL,EAAE,EAAE,EAAE,IAAI,SAAS,EAAE;QACrB,OAAO,EAAE,KAAK;QACd,MAAM;QACN,MAAM;KACP,CAAC;AACJ,CAAC;AAEK,SAAU,mBAAmB,CAAU,EAAU,EAAE,MAAS;IAChE,OAAO;QACL,EAAE;QACF,OAAO,EAAE,KAAK;QACd,MAAM;KACP,CAAC;AACJ,CAAC;AAEK,SAAU,kBAAkB,CAChC,EAAU,EACV,KAA8B,EAC9B,IAAa;IAEb,OAAO;QACL,EAAE;QACF,OAAO,EAAE,KAAK;QACd,KAAK,EAAE,kBAAkB,CAAC,KAAK,EAAE,IAAI,CAAC;KACvC,CAAC;AACJ,CAAC;AAEK,SAAU,kBAAkB,CAAC,KAA8B,EAAE,IAAa;IAC9E,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;QAChC,uLAAO,WAAA,AAAQ,kLAAC,iBAAc,CAAC,CAAC;KACjC;IACD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,KAAK,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,mLACA,WAAA,AAAQ,kLAAC,eAAY,CAAC,GAAA;YACzB,OAAO,EAAE,KAAK;QAAA,EACf,CAAC;KACH;IACD,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;QAC/B,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;KACnB;IACD,oLAAI,sBAAA,AAAmB,EAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QACnC,KAAK,mLAAG,iBAAA,AAAc,EAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACpC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1655, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1661, "column": 0}, "map": {"version":3,"file":"routing.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/routing.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/routing.ts"],"names":[],"mappings":";;;;;;;AAAM,SAAU,YAAY,CAAC,KAAa;IACxC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACvB,OAAO,oBAAoB,CAAC,KAAK,CAAC,CAAC;KACpC;IACD,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QACrB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAEK,SAAU,mBAAmB,CAAC,KAAa;IAC/C,OAAO,KAAK,KAAK,GAAG,CAAC;AACvB,CAAC;AAEK,SAAU,oBAAoB,CAAC,KAAa;IAChD,IAAI,mBAAmB,CAAC,KAAK,CAAC,EAAE;QAC9B,OAAO,IAAI,CAAC;KACb;IACD,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC;KACd;IACD,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;QACjC,OAAO,KAAK,CAAC;KACd;IACD,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;QAC9D,OAAO,KAAK,CAAC;KACd;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAEK,SAAU,2BAA2B,CAAC,KAAa;IACvD,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACnG,CAAC;AAEK,SAAU,4BAA4B,CAAC,KAAa;IACxD,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACnG,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1701, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1707, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/types.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/types.ts"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 1710, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1725, "column": 0}, "map": {"version":3,"file":"url.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/url.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/url.ts"],"names":[],"mappings":";;;;;AAAA,MAAM,UAAU,GAAG,UAAU,CAAC;AAE9B,MAAM,QAAQ,GAAG,QAAQ,CAAC;AAE1B,SAAS,cAAc,CAAC,GAAW;IACjC,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;IACrD,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO;IACxC,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC;AAED,SAAS,kBAAkB,CAAC,GAAW,EAAE,KAAa;IACpD,MAAM,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC;IACrC,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,OAAO,KAAK,CAAC;IAClD,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC1C,CAAC;AAEK,SAAU,SAAS,CAAC,GAAW;IACnC,OAAO,kBAAkB,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;AAC7C,CAAC;AAEK,SAAU,OAAO,CAAC,GAAW;IACjC,OAAO,kBAAkB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAC3C,CAAC;AAEK,SAAU,cAAc,CAAC,GAAW;IACxC,OAAO,IAAI,MAAM,CAAC,4BAA4B,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1751, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"file":"validators.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/validators.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/validators.ts"],"names":[],"mappings":";;;;;;;;AAUM,SAAU,gBAAgB,CAAC,OAAY;IAC3C,OAAO,AACL,OAAO,OAAO,KAAK,QAAQ,IAC3B,IAAI,IAAI,OAAO,IACf,SAAS,IAAI,OAAO,IACpB,OAAO,CAAC,OAAO,KAAK,KAAK,CAC1B,CAAC;AACJ,CAAC;AAEK,SAAU,gBAAgB,CAAU,OAAuB;IAC/D,OAAO,gBAAgB,CAAC,OAAO,CAAC,IAAI,QAAQ,IAAI,OAAO,CAAC;AAC1D,CAAC;AAEK,SAAU,iBAAiB,CAAU,OAAuB;IAChE,OAAO,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;AAC5F,CAAC;AAEK,SAAU,eAAe,CAAU,OAAuB;IAC9D,OAAO,QAAQ,IAAI,OAAO,CAAC;AAC7B,CAAC;AAEK,SAAU,cAAc,CAAC,OAAuB;IACpD,OAAO,OAAO,IAAI,OAAO,CAAC;AAC5B,CAAC;AAEK,SAAU,0BAA0B,CACxC,UAA6B;IAE7B,OAAO,OAAO,IAAI,UAAU,IAAI,UAAU,CAAC,KAAK,KAAK,KAAK,CAAC;AAC7D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1783, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1789, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-utils/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/jsonrpc-utils/src/index.ts"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 1799, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1820, "column": 0}, "map": {"version":3,"file":"crypto.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/environment/src/crypto.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/environment/src/crypto.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,eAAe;IAE7B,OAAO,CAAA,MAAM,KAAA,QAAN,MAAM,KAAA,KAAA,IAAA,KAAA,IAAN,MAAM,CAAE,MAAM,KAAA,CAAI,MAAM,KAAA,QAAN,MAAM,KAAA,KAAA,IAAA,KAAA,IAAN,MAAM,CAAE,QAAQ,CAAA,IAAI,CAAA,CAAE,CAAC;AAClD,CAAC;AAHD,QAAA,eAAA,GAAA,gBAGC;AAED,SAAgB,eAAe;IAC7B,MAAM,aAAa,GAAG,eAAe,EAAE,CAAC;IAExC,OAAO,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,YAAY,CAAC;AAC5D,CAAC;AAJD,QAAA,eAAA,GAAA,gBAIC;AAED,SAAgB,wBAAwB;IACtC,OAAO,CAAC,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC,eAAe,EAAE,CAAC;AACpD,CAAC;AAFD,QAAA,wBAAA,GAAA,yBAEC","ignoreList":[0]}},
    {"offset": {"line": 1838, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1843, "column": 0}, "map": {"version":3,"file":"env.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/environment/src/env.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/environment/src/env.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,aAAa;IAC3B,OAAO,AACL,OAAO,QAAQ,KAAK,WAAW,IAC/B,OAAO,SAAS,KAAK,WAAW,IAChC,SAAS,CAAC,OAAO,KAAK,aAAa,CACpC,CAAC;AACJ,CAAC;AAND,QAAA,aAAA,GAAA,cAMC;AAED,SAAgB,MAAM;IACpB,OAAO,AACL,OAAO,OAAO,KAAK,WAAW,IAC9B,OAAO,OAAO,CAAC,QAAQ,KAAK,WAAW,IACvC,OAAO,OAAO,CAAC,QAAQ,CAAC,IAAI,KAAK,WAAW,CAC7C,CAAC;AACJ,CAAC;AAND,QAAA,MAAA,GAAA,OAMC;AAED,SAAgB,SAAS;IACvB,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;AACvC,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC","ignoreList":[0]}},
    {"offset": {"line": 1860, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1865, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/environment/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/environment/src/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,uHAAA,SAAyB;AACzB,QAAA,YAAA,oHAAA,SAAsB","ignoreList":[0]}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1878, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-types/src/misc.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-types/src/provider.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\n\nexport abstract class IEvents {\n  public abstract events: EventEmitter;\n\n  // events\n  public abstract on(event: string, listener: any): void;\n  public abstract once(event: string, listener: any): void;\n  public abstract off(event: string, listener: any): void;\n  public abstract removeListener(event: string, listener: any): void;\n}\n","import { JsonRpcPayload, JsonRpcRequest, RequestArguments } from \"./jsonrpc\";\nimport { IEvents } from \"./misc\";\n\nexport abstract class IJsonRpcConnection extends IEvents {\n  public abstract connected: boolean;\n  public abstract connecting: boolean;\n  // @ts-ignore - opts is not used in abstract class constructor\n  constructor(opts?: any) {\n    super();\n  }\n\n  public abstract open(opts?: any): Promise<void>;\n  public abstract close(): Promise<void>;\n  public abstract send(payload: JsonRpcPayload, context?: any): Promise<void>;\n}\n\nexport abstract class IBaseJsonRpcProvider extends IEvents {\n  // eslint-disable-next-line no-useless-constructor\n  constructor() {\n    super();\n  }\n\n  public abstract connect(params?: any): Promise<void>;\n\n  public abstract disconnect(): Promise<void>;\n\n  public abstract request<Result = any, Params = any>(\n    request: RequestArguments<Params>,\n    context?: any,\n  ): Promise<Result>;\n\n  // ---------- Protected ----------------------------------------------- //\n\n  protected abstract requestStrict<Result = any, Params = any>(\n    request: JsonRpcRequest<Params>,\n    context?: any,\n  ): Promise<Result>;\n}\n\nexport abstract class IJsonRpcProvider extends IBaseJsonRpcProvider {\n  public abstract connection: IJsonRpcConnection;\n\n  // @ts-ignore - connection is not used in abstract class constructor\n  constructor(connection: string | IJsonRpcConnection) {\n    super();\n  }\n\n  public abstract connect(connection?: string | IJsonRpcConnection): Promise<void>;\n\n  // ---------- Protected ----------------------------------------------- //\n\n  protected abstract setConnection(connection?: string | IJsonRpcConnection): IJsonRpcConnection;\n\n  protected abstract onPayload(payload: JsonRpcPayload): void;\n\n  protected abstract open(connection?: string | IJsonRpcConnection): Promise<void>;\n\n  protected abstract close(): Promise<void>;\n}\n"],"names":["IEvents","opts","connection"],"mappings":";;;;;;AAEO,MAAe;AAAA;AAAA,IAAQ,EAAA,UAAA;IAAA,YAAA,CAAA,CAAA;QAAA,KAAA;IAAA;AAAA;AAAA,MAAA,UAAA;IAAA,aAAA;QAAA,KAAA;IAAA;AAAA;AAAA,MAAA,UAAA;IAAA,YAAA,CAAA,CAAA;QAAA,KAAA;IAAA;AAAA","ignoreList":[0,1]}},
    {"offset": {"line": 1903, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1909, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-http-connection/src/http.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport {\n  formatJsonRpcError,\n  IJsonRpcConnection,\n  JsonRpcPayload,\n  isHttpUrl,\n  parseConnectionError,\n} from \"@walletconnect/jsonrpc-utils\";\n\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\",\n};\n\nconst DEFAULT_HTTP_METHOD = \"POST\";\n\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD,\n};\n\n// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\n\nexport class HttpConnection implements IJsonRpcConnection {\n  public events = new EventEmitter();\n\n  private isAvailable = false;\n\n  private registering = false;\n\n  constructor(public url: string, public disableProviderPing = false) {\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    this.url = url;\n    this.disableProviderPing = disableProviderPing;\n  }\n\n  get connected(): boolean {\n    return this.isAvailable;\n  }\n\n  get connecting(): boolean {\n    return this.registering;\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url);\n  }\n\n  public async close(): Promise<void> {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n    this.onClose();\n  }\n\n  public async send(payload: JsonRpcPayload): Promise<void> {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, { ...DEFAULT_FETCH_OPTS, body });\n      const data = await res.json();\n      this.onPayload({ data });\n    } catch (e) {\n      this.onError(payload.id, e as any);\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async register(url = this.url): Promise<void> {\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (\n        this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n        this.events.listenerCount(\"open\") >= currentMaxListeners\n      ) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", (error) => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n          resolve();\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n    try {\n      if (!this.disableProviderPing) {\n        const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n        await fetch(url, { ...DEFAULT_FETCH_OPTS, body });\n      }\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e as any);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n\n  private onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  private onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n\n  private onPayload(e: { data: any }) {\n    if (typeof e.data === \"undefined\") return;\n    const payload: JsonRpcPayload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  private onError(id: number, e: Error) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n\n  private resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n}\n\nexport default HttpConnection;\n"],"names":["DEFAULT_HTTP_HEADERS","DEFAULT_HTTP_METHOD","DEFAULT_FETCH_OPTS","EVENT_EMITTER_MAX_LISTENERS_DEFAULT","url","disableProviderPing","EventEmitter","isHttpUrl","event","listener","payload","body","safeJsonStringify","data","fetch","__spreadProps","__spreadValues","e","currentMaxListeners","resolve","reject","error","safeJsonParse","id","message","formatJsonRpcError","parseConnectionError"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 2040, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2046, "column": 0}, "map": {"version":3,"file":"provider.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/jsonrpc-provider/src/provider.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/jsonrpc-provider/src/provider.ts"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2163, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/universal-provider/node_modules/%40walletconnect/jsonrpc-provider/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/universal-provider/node_modules/@walletconnect/jsonrpc-provider/src/index.ts"],"names":[],"mappings":";;;AAAA,OAAO,QAAQ,MAAM,YAAY,CAAC;;;qRAInB,UAAQ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2186, "column": 0}, "map": {"version":3,"file":"provider.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/jsonrpc-provider/src/provider.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/core/node_modules/@walletconnect/jsonrpc-provider/src/provider.ts"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,EAEL,gBAAgB,EAKhB,iBAAiB,EACjB,oBAAoB,EACpB,cAAc,EACd,cAAc,GACf,MAAM,8BAA8B,CAAC;;;;;;AAEhC,MAAO,eAAgB,oLAAQ,mBAAgB;IAOnD,YAAY,UAA8B,CAAA;QACxC,KAAK,CAAC,UAAU,CAAC,CAAC;QAPb,IAAA,CAAA,MAAM,GAAG,0GAAI,eAAY,EAAE,CAAC;QAI3B,IAAA,CAAA,2BAA2B,GAAG,KAAK,CAAC;QAI1C,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QACjD,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;YAC7B,IAAI,CAAC,sBAAsB,EAAE,CAAC;SAC/B;IACH,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,aAA0C,IAAI,CAAC,UAAU,EAAA;QAC5E,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC9B,CAAC;IAEM,KAAK,CAAC,UAAU,GAAA;QACrB,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC;IACrB,CAAC;IAEM,EAAE,CAAC,KAAa,EAAE,QAAa,EAAA;QACpC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAClC,CAAC;IAEM,IAAI,CAAC,KAAa,EAAE,QAAa,EAAA;QACtC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACpC,CAAC;IAEM,GAAG,CAAC,KAAa,EAAE,QAAa,EAAA;QACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACnC,CAAC;IAEM,cAAc,CAAC,KAAa,EAAE,QAAa,EAAA;QAChD,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAEM,KAAK,CAAC,OAAO,CAClB,OAAiC,EACjC,OAAa,EAAA;QAEb,OAAO,IAAI,CAAC,aAAa,kLACvB,uBAAoB,AAApB,EACE,OAAO,CAAC,MAAM,EACd,OAAO,CAAC,MAAM,IAAI,EAAE,EACpB,OAAO,CAAC,EAAE,KAAK,iMAAA,AAAc,EAAE,EAAC,QAAQ,EAAU,CACnD,EACD,OAAO,CACR,CAAC;IACJ,CAAC;IAIS,KAAK,CAAC,aAAa,CAC3B,OAA+B,EAC/B,OAAa,EAAA;QAEb,OAAO,IAAI,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE;YAC3C,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;gBAC9B,IAAI;oBACF,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;iBACnB,CAAC,OAAO,CAAC,EAAE;oBACV,MAAM,CAAC,CAAC,CAAC,CAAC;iBACX;aACF;YACD,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,EAAE,GAAE,QAAQ,CAAC,EAAE;gBACzC,QAAI,kMAAA,AAAc,EAAC,QAAQ,CAAC,EAAE;oBAC5B,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;iBACxB,MAAM;oBACL,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBAC1B;YACH,CAAC,CAAC,CAAC;YACH,IAAI;gBACF,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;aAC9C,CAAC,OAAO,CAAC,EAAE;gBACV,MAAM,CAAC,CAAC,CAAC,CAAC;aACX;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAES,aAAa,CAAC,aAAiC,IAAI,CAAC,UAAU,EAAA;QACtE,OAAO,UAAU,CAAC;IACpB,CAAC;IAES,SAAS,CAAC,OAAuB,EAAA;QACzC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QACrC,yLAAI,oBAAA,AAAiB,EAAC,OAAO,CAAC,EAAE;YAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC;SAC5C,MAAM;YACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE;gBAC1B,IAAI,EAAE,OAAO,CAAC,MAAM;gBACpB,IAAI,EAAE,OAAO,CAAC,MAAM;aACK,CAAC,CAAC;SAC9B;IACH,CAAC;IAES,OAAO,CAAC,KAAkB,EAAA;QAElC,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,EAAE;YAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,OAAO,EACP,IAAI,KAAK,CACP,CAAA,kDAAA,EAAqD,KAAK,CAAC,IAAI,CAAA,CAAA,EAC7D,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,KAAK,CAAC,MAAM,CAAA,CAAA,CAAG,CAAC,CAAC,CAAC,EACvC,EAAE,CACH,CACF,CAAC;SACH;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACjC,CAAC;IAES,KAAK,CAAC,IAAI,CAAC,aAA0C,IAAI,CAAC,UAAU,EAAA;QAC5E,IAAI,IAAI,CAAC,UAAU,KAAK,UAAU,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,OAAO;QACxE,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC;QAC5C,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAClC,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACvC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;SAC9B;QACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QACjD,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;QAC7B,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAC9B,CAAC;IAES,KAAK,CAAC,KAAK,GAAA;QACnB,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;IAChC,CAAC;IAIO,sBAAsB,GAAA;QAC5B,IAAI,IAAI,CAAC,2BAA2B,EAAE,OAAO;QAC7C,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,OAAuB,EAAE,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;QACpF,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAkB,EAAE,CAAG,CAAD,GAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACzE,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,CAAG,CAAD,GAAK,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAChF,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,gBAAgB,EAAE,CAAC,KAAY,EAAE,CAAG,CAAD,GAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QACvE,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC;IAC1C,CAAC;CACF;uCAEc,eAAe,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2297, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2303, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/jsonrpc-provider/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/core/node_modules/@walletconnect/jsonrpc-provider/src/index.ts"],"names":[],"mappings":";;;AAAA,OAAO,QAAQ,MAAM,YAAY,CAAC;;;oQAInB,UAAQ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2311, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2325, "column": 0}, "map": {"version":3,"file":"delay.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/utils/delay.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/utils/delay.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,KAAK,CAAC,OAAe;IACnC,OAAO,IAAI,OAAO,EAAC,OAAO,CAAC,EAAE;QAC3B,UAAU,CAAC,GAAG,EAAE;YACd,OAAO,CAAC,IAAI,CAAC,CAAC;QAChB,CAAC,EAAE,OAAO,CAAC,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;AAND,QAAA,KAAA,GAAA,MAMC","ignoreList":[0]}},
    {"offset": {"line": 2338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2343, "column": 0}, "map": {"version":3,"file":"misc.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/constants/misc.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/constants/misc.ts"],"names":[],"mappings":";;;;;AAEa,QAAA,WAAW,GAAG,GAAG,CAAC;AAElB,QAAA,YAAY,GAAG,IAAI,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2350, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2355, "column": 0}, "map": {"version":3,"file":"time.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/constants/time.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/constants/time.ts"],"names":[],"mappings":";;;;;AAEa,QAAA,UAAU,GAAG,CAAC,CAAC;AAEf,QAAA,YAAY,GAAG,CAAC,CAAC;AAEjB,QAAA,WAAW,GAAG,EAAE,CAAC;AAEjB,QAAA,cAAc,GAAG,EAAE,CAAC;AAEpB,QAAA,aAAa,GAAG,EAAE,CAAC;AAInB,QAAA,UAAU,GAAG,QAAA,aAAa,CAAC;AAE3B,QAAA,YAAY,GAAG,QAAA,UAAU,GAAG,CAAC,CAAC;AAE9B,QAAA,WAAW,GAAG,QAAA,UAAU,GAAG,EAAE,CAAC;AAE9B,QAAA,cAAc,GAAG,QAAA,UAAU,GAAG,EAAE,CAAC;AAEjC,QAAA,aAAa,GAAG,QAAA,UAAU,GAAG,EAAE,CAAC;AAIhC,QAAA,QAAQ,GAAG,QAAA,aAAa,CAAC;AAEzB,QAAA,WAAW,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAE3B,QAAA,SAAS,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAEzB,QAAA,YAAY,GAAG,QAAA,QAAQ,GAAG,EAAE,CAAC;AAE7B,QAAA,iBAAiB,GAAG,QAAA,QAAQ,GAAG,EAAE,CAAC;AAIlC,QAAA,OAAO,GAAG,QAAA,iBAAiB,CAAC;AAE5B,QAAA,UAAU,GAAG,QAAA,OAAO,GAAG,CAAC,CAAC;AAEzB,QAAA,SAAS,GAAG,QAAA,OAAO,GAAG,CAAC,CAAC;AAExB,QAAA,UAAU,GAAG,QAAA,OAAO,GAAG,CAAC,CAAC;AAEzB,QAAA,WAAW,GAAG,QAAA,OAAO,GAAG,EAAE,CAAC;AAI3B,QAAA,QAAQ,GAAG,QAAA,UAAU,CAAC;AAEtB,QAAA,SAAS,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAEzB,QAAA,WAAW,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAE3B,QAAA,UAAU,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAI1B,QAAA,QAAQ,GAAG,QAAA,OAAO,GAAG,GAAG,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2390, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/constants/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/constants/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,wHAAA,SAAuB;AACvB,QAAA,YAAA,wHAAA,SAAuB","ignoreList":[0]}},
    {"offset": {"line": 2397, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2402, "column": 0}, "map": {"version":3,"file":"convert.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/utils/convert.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/utils/convert.ts"],"names":[],"mappings":";;;;;AAAA,MAAA,sCAA4C;AAE5C,SAAgB,aAAa,CAAC,OAAe;IAC3C,OAAO,OAAO,GAAG,YAAA,YAAY,CAAC;AAChC,CAAC;AAFD,QAAA,aAAA,GAAA,cAEC;AAED,SAAgB,eAAe,CAAC,WAAmB;IACjD,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,YAAA,YAAY,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC","ignoreList":[0]}},
    {"offset": {"line": 2416, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2421, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/utils/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/utils/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,qHAAA,SAAwB;AACxB,QAAA,YAAA,uHAAA,SAA0B","ignoreList":[0]}},
    {"offset": {"line": 2428, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2433, "column": 0}, "map": {"version":3,"file":"watch.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/watch.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/watch.ts"],"names":[],"mappings":";;;;;AAEA,MAAa,KAAK;IAAlB,aAAA;QACS,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAyB,CAAC;IA+BvD,CAAC;IA7BQ,KAAK,CAAC,KAAa,EAAA;QACxB,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,CAAA,iCAAA,EAAoC,KAAK,EAAE,CAAC,CAAC;SAC9D;QACD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE;YAAE,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;QAAA,CAAE,CAAC,CAAC;IACtD,CAAC;IAEM,IAAI,CAAC,KAAa,EAAA;QACvB,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,OAAO,SAAS,CAAC,OAAO,KAAK,WAAW,EAAE;YAC5C,MAAM,IAAI,KAAK,CAAC,CAAA,iCAAA,EAAoC,KAAK,EAAE,CAAC,CAAC;SAC9D;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC;QAC/C,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE;YAAE,OAAO,EAAE,SAAS,CAAC,OAAO;YAAE,OAAO;QAAA,CAAE,CAAC,CAAC;IACtE,CAAC;IAEM,GAAG,CAAC,KAAa,EAAA;QACtB,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC7C,IAAI,OAAO,SAAS,KAAK,WAAW,EAAE;YACpC,MAAM,IAAI,KAAK,CAAC,CAAA,8BAAA,EAAiC,KAAK,EAAE,CAAC,CAAC;SAC3D;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEM,OAAO,CAAC,KAAa,EAAA;QAC1B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC;QACpE,OAAO,OAAO,CAAC;IACjB,CAAC;CACF;AAhCD,QAAA,KAAA,GAAA,MAgCC;AAED,QAAA,OAAA,GAAe,KAAK,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2481, "column": 0}, "map": {"version":3,"file":"watch.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/types/watch.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/types/watch.ts"],"names":[],"mappings":";;;;;AAKA,MAAsB,MAAM;CAU3B;AAVD,QAAA,MAAA,GAAA,OAUC","ignoreList":[0]}},
    {"offset": {"line": 2489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/types/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/types/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,qHAAA,SAAwB","ignoreList":[0]}},
    {"offset": {"line": 2500, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2505, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/time/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/time/src/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,qHAAA,SAAwB;AACxB,QAAA,YAAA,+GAAA,SAAwB;AACxB,QAAA,YAAA,qHAAA,SAAwB;AACxB,QAAA,YAAA,yHAAA,SAA4B","ignoreList":[0]}},
    {"offset": {"line": 2514, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2519, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/window-getters/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/window-getters/src/index.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,aAAa,CAAI,IAAY;IAC3C,IAAI,GAAG,GAAkB,SAAS,CAAC;IACnC,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,WAAW,EAAE;QACxE,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;KACpB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,aAAA,GAAA,cAMC;AAED,SAAgB,oBAAoB,CAAI,IAAY;IAClD,MAAM,GAAG,GAAG,aAAa,CAAI,IAAI,CAAC,CAAC;IACnC,IAAI,CAAC,GAAG,EAAE;QACR,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAA,yBAAA,CAA2B,CAAC,CAAC;KACrD;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,oBAAA,GAAA,qBAMC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,mBAAmB;IACjC,OAAO,oBAAoB,CAAY,WAAW,CAAC,CAAC;AACtD,CAAC;AAFD,QAAA,mBAAA,GAAA,oBAEC;AAED,SAAgB,YAAY;IAC1B,OAAO,aAAa,CAAY,WAAW,CAAC,CAAC;AAC/C,CAAC;AAFD,QAAA,YAAA,GAAA,aAEC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,gBAAgB;IAC9B,OAAO,oBAAoB,CAAS,QAAQ,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,gBAAA,GAAA,iBAEC;AAED,SAAgB,SAAS;IACvB,OAAO,aAAa,CAAS,QAAQ,CAAC,CAAC;AACzC,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC;AAED,SAAgB,sBAAsB;IACpC,OAAO,oBAAoB,CAAU,cAAc,CAAC,CAAC;AACvD,CAAC;AAFD,QAAA,sBAAA,GAAA,uBAEC;AAED,SAAgB,eAAe;IAC7B,OAAO,aAAa,CAAU,cAAc,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC","ignoreList":[0]}},
    {"offset": {"line": 2580, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2585, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/window-metadata/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/window-metadata/src/index.ts"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2680, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2686, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-api/src/misc.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-api/src/validators.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-api/src/parsers.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-api/src/jsonrpc.ts"],"sourcesContent":["export function assertType(obj: any, key: string, type = \"string\") {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\nexport function hasRequiredParams(params: any, required: string[]) {\n  let matches = true;\n  required.forEach((key) => {\n    const exists = key in params;\n    if (!exists) {\n      matches = false;\n    }\n  });\n  return matches;\n}\n\nexport function hasExactParamsLength(params: any, length: number): boolean {\n  return Array.isArray(params) ? params.length === length : Object.keys(params).length === length;\n}\n\nexport function hasRequiredParamsLength(params: any, minLength: number): boolean {\n  return Array.isArray(params)\n    ? params.length >= minLength\n    : Object.keys(params).length >= minLength;\n}\n\nexport function checkParams(params: any, required: string[], optional: string[]) {\n  const exact = !optional.length;\n  const matchesLength = exact\n    ? hasExactParamsLength(params, required.length)\n    : hasRequiredParamsLength(params, required.length);\n  if (!matchesLength) return false;\n  return hasRequiredParams(params, required);\n}\n\nexport function methodEndsWith(method: string, expected: string, separator = \"_\") {\n  const split = method.split(separator);\n  return split[split.length - 1].trim().toLowerCase() === expected.trim().toLowerCase();\n}\n","import { JsonRpcRequest } from \"@walletconnect/jsonrpc-types\";\n\nimport { checkParams, methodEndsWith } from \"./misc\";\nimport { RelayJsonRpc } from \"./types\";\n\n// ---------- Subscribe ----------------------------------------------- //\n\nexport function isSubscribeRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.SubscribeParams> {\n  return isSubscribeMethod(request.method) && isSubscribeParams(request.params);\n}\n\nexport function isSubscribeMethod(method: string): boolean {\n  return methodEndsWith(method, \"subscribe\");\n}\n\nexport function isSubscribeParams(params: any): params is RelayJsonRpc.SubscribeParams {\n  const required = [\"topic\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Publish ----------------------------------------------- //\n\nexport function isPublishRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.PublishParams> {\n  return isPublishMethod(request.method) && isPublishParams(request.params);\n}\n\nexport function isPublishMethod(method: string): boolean {\n  return methodEndsWith(method, \"publish\");\n}\n\nexport function isPublishParams(params: any): params is RelayJsonRpc.PublishParams {\n  const required = [\"message\", \"topic\", \"ttl\"];\n  const optional = [\"prompt\", \"tag\"];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Unsubscribe ----------------------------------------------- //\n\nexport function isUnsubscribeRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.UnsubscribeParams> {\n  return isUnsubscribeMethod(request.method) && isUnsubscribeParams(request.params);\n}\n\nexport function isUnsubscribeMethod(method: string): boolean {\n  return methodEndsWith(method, \"unsubscribe\");\n}\n\nexport function isUnsubscribeParams(params: any): params is RelayJsonRpc.UnsubscribeParams {\n  const required = [\"id\", \"topic\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Subscription ----------------------------------------------- //\n\nexport function isSubscriptionRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.SubscriptionParams> {\n  return isSubscriptionMethod(request.method) && isSubscriptionParams(request.params);\n}\n\nexport function isSubscriptionMethod(method: string): boolean {\n  return methodEndsWith(method, \"subscription\");\n}\n\nexport function isSubscriptionParams(params: any): params is RelayJsonRpc.SubscriptionParams {\n  const required = [\"id\", \"data\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n","import { JsonRpcRequest } from \"@walletconnect/jsonrpc-types\";\n\nimport { RelayJsonRpc } from \"./types\";\nimport { assertType } from \"./misc\";\nimport {\n  isPublishMethod,\n  isPublishParams,\n  isSubscribeMethod,\n  isSubscribeParams,\n  isSubscriptionMethod,\n  isSubscriptionParams,\n  isUnsubscribeMethod,\n  isUnsubscribeParams,\n} from \"./validators\";\n\nexport function parseSubscribeRequest(request: JsonRpcRequest): RelayJsonRpc.SubscribeParams {\n  if (!isSubscribeMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid subscribe method\");\n  }\n  if (!isSubscribeParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid subscribe params\");\n  }\n  const params = request.params as RelayJsonRpc.SubscribeParams;\n\n  assertType(params, \"topic\");\n\n  return params;\n}\n\nexport function parsePublishRequest(request: JsonRpcRequest): RelayJsonRpc.PublishParams {\n  if (!isPublishMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid publish method\");\n  }\n  if (!isPublishParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid publish params\");\n  }\n  const params = request.params as RelayJsonRpc.PublishParams;\n\n  assertType(params, \"topic\");\n  assertType(params, \"message\");\n  assertType(params, \"ttl\", \"number\");\n\n  return params;\n}\n\nexport function parseUnsubscribeRequest(request: JsonRpcRequest): RelayJsonRpc.UnsubscribeParams {\n  if (!isUnsubscribeMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid unsubscribe method\");\n  }\n  if (!isUnsubscribeParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid unsubscribe params\");\n  }\n  const params = request.params as RelayJsonRpc.UnsubscribeParams;\n\n  assertType(params, \"id\");\n\n  return params;\n}\n\nexport function parseSubscriptionRequest(request: JsonRpcRequest): RelayJsonRpc.SubscriptionParams {\n  if (!isSubscriptionMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid subscription method\");\n  }\n  if (!isSubscriptionParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid subscription params\");\n  }\n  const params = request.params as RelayJsonRpc.SubscriptionParams;\n\n  assertType(params, \"id\");\n  assertType(params, \"data\");\n\n  return params;\n}\n","import { RelayJsonRpc } from \"./types\";\n\nexport const RELAY_JSONRPC: { [protocol: string]: RelayJsonRpc.Methods } = {\n  waku: {\n    publish: \"waku_publish\",\n    batchPublish: \"waku_batchPublish\",\n    subscribe: \"waku_subscribe\",\n    batchSubscribe: \"waku_batchSubscribe\",\n    subscription: \"waku_subscription\",\n    unsubscribe: \"waku_unsubscribe\",\n    batchUnsubscribe: \"waku_batchUnsubscribe\",\n    batchFetchMessages: \"waku_batchFetchMessages\",\n  },\n  irn: {\n    publish: \"irn_publish\",\n    batchPublish: \"irn_batchPublish\",\n    subscribe: \"irn_subscribe\",\n    batchSubscribe: \"irn_batchSubscribe\",\n    subscription: \"irn_subscription\",\n    unsubscribe: \"irn_unsubscribe\",\n    batchUnsubscribe: \"irn_batchUnsubscribe\",\n    batchFetchMessages: \"irn_batchFetchMessages\",\n  },\n  iridium: {\n    publish: \"iridium_publish\",\n    batchPublish: \"iridium_batchPublish\",\n    subscribe: \"iridium_subscribe\",\n    batchSubscribe: \"iridium_batchSubscribe\",\n    subscription: \"iridium_subscription\",\n    unsubscribe: \"iridium_unsubscribe\",\n    batchUnsubscribe: \"iridium_batchUnsubscribe\",\n    batchFetchMessages: \"iridium_batchFetchMessages\",\n  },\n};\n"],"names":["obj","key","type","params","required","matches","length","minLength","optional","method","expected","separator","split","request","methodEndsWith","checkParams","isSubscribeMethod","isSubscribeParams","assertType","isPublishMethod","isPublishParams","isUnsubscribeMethod","isUnsubscribeParams","isSubscriptionMethod","isSubscriptionParams"],"mappings":"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","ignoreList":[0,1,2,3]}},
    {"offset": {"line": 2836, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2842, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/caip.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/cacao.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/crypto.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/misc.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/relay.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/uri.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/namespaces.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/errors.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/validators.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/network.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/utils/src/memoryStore.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","export interface CacaoPayload {\n  iss: string;\n  domain: string;\n  aud: string;\n  version: string;\n  nonce: string;\n  iat: string;\n  nbf?: string;\n  exp?: string;\n  statement?: string;\n  requestId?: string;\n  resources?: string[];\n}\n\nexport interface CacaoHeader {\n  t: \"eip4361\";\n}\n\nexport interface CacaoSignature {\n  t: \"eip191\" | \"eip1271\";\n  s: string;\n  m?: string;\n}\n\nexport interface Cacao {\n  h: CacaoHeader;\n  p: CacaoPayload;\n  s: CacaoSignature;\n}\n\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[3];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport const formatMessage = (cacao: CacaoPayload, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n  const statement = cacao.statement;\n  const uri = `URI: ${cacao.aud}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const resources =\n    cacao.resources && cacao.resources.length > 0\n      ? `Resources:\\n${cacao.resources.map((resource) => `- ${resource}`).join(\"\\n\")}`\n      : undefined;\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n    true,\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize(params.encoded);\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(encoded: string): CryptoTypes.EncodingParams {\n  const bytes = fromString(encoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize(encoded);\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator() && !!getDocument();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\nexport function getBundleId(): string | undefined {\n  try {\n    if (\n      isReactNative() &&\n      typeof global !== \"undefined\" &&\n      typeof (global as any)?.Application !== \"undefined\"\n    ) {\n      return (global as any).Application?.applicationId;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const env = getEnvironment();\n  // global.Platform is set by react-native-compat\n  if (\n    env === ENV_MAP.reactNative &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\"\n  ) {\n    const { OS, Version } = (global as any).Platform;\n    return [OS, Version].join(\"-\");\n  }\n\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n  useOnCloseEvent,\n  bundleId,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = {\n    auth,\n    ua,\n    projectId,\n    useOnCloseEvent: useOnCloseEvent || undefined,\n    origin: bundleId || undefined,\n  };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(\n  expiry: number = FIVE_MINUTES,\n  expireErrorMessage?: string,\n) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      cacheTimeout = setTimeout(() => {\n        promiseReject(new Error(expireErrorMessage));\n      }, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(\n  promise: Promise<T>,\n  expiry: number,\n  expireErrorMessage?: string,\n) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(expireErrorMessage)), expiry);\n    try {\n      const result = await promise;\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n    clearTimeout(timeout);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return Date.now() >= toMiliseconds(expiry);\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n\nexport function mergeArrays<T>(a: T[] = [], b: T[] = []): T[] {\n  return [...new Set([...a, ...b])];\n}\n\nexport async function handleDeeplinkRedirect({\n  id,\n  topic,\n  wcDeepLink,\n}: {\n  id: number;\n  topic: string;\n  wcDeepLink: string;\n}) {\n  try {\n    if (!wcDeepLink) return;\n\n    const json = typeof wcDeepLink === \"string\" ? JSON.parse(wcDeepLink) : wcDeepLink;\n    let deeplink = json?.href;\n\n    if (typeof deeplink !== \"string\") return;\n\n    if (deeplink.endsWith(\"/\")) deeplink = deeplink.slice(0, -1);\n\n    const link = `${deeplink}/wc?requestId=${id}&sessionTopic=${topic}`;\n\n    const env = getEnvironment();\n\n    if (env === ENV_MAP.browser) {\n      if (link.startsWith(\"https://\")) {\n        window.open(link, \"_blank\", \"noreferrer noopener\");\n      } else {\n        window.open(link, \"_self\", \"noreferrer noopener\");\n      }\n    } else if (env === ENV_MAP.reactNative) {\n      // global.Linking is set by react-native-compat\n      if (typeof (global as any)?.Linking !== \"undefined\") {\n        await (global as any).Linking.openURL(link);\n      }\n    }\n  } catch (err) {\n    // Silent error, just log in console\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n}\n\nexport async function getDeepLink(store: IKeyValueStorage, key: string) {\n  try {\n    const deepLink = await store.getItem(key);\n    if (deepLink) return deepLink;\n\n    // check localStorage as fallback\n    if (!isBrowser()) return;\n    return localStorage.getItem(key) as string;\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  // remove android schema prefix\n  str = str.includes(\"wc://\") ? str.replace(\"wc://\", \"\") : str;\n  // remove ios schema prefix\n  str = str.includes(\"wc:\") ? str.replace(\"wc:\", \"\") : str;\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const result = {\n    protocol,\n    topic: parseTopic(requiredValues[0]),\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n    expiryTimestamp: queryParams.expiryTimestamp\n      ? parseInt(queryParams.expiryTimestamp as string, 10)\n      : undefined,\n  };\n  return result;\n}\n\nexport function parseTopic(topic: string): string {\n  return topic.startsWith(\"//\") ? topic.substring(2) : topic;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n      expiryTimestamp: params.expiryTimestamp,\n    })\n  );\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { mergeArrays } from \"./misc\";\nimport { isConformingNamespaces, isValidNamespaces, isValidObject } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n\nexport type BuildApprovedNamespacesParams = {\n  proposal: ProposalTypes.Struct;\n  supportedNamespaces: Record<\n    string,\n    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }\n  >;\n};\n\n/**\n * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.\n * It takes required & optional namespaces provided in the session proposal\n * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object\n * @param {BuildApprovedNamespacesParams} params\n * @returns {SessionTypes.Namespaces}\n */\nexport function buildApprovedNamespaces(\n  params: BuildApprovedNamespacesParams,\n): SessionTypes.Namespaces {\n  const {\n    proposal: { requiredNamespaces, optionalNamespaces = {} },\n    supportedNamespaces,\n  } = params;\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  // build approved namespaces\n  const namespaces = {};\n  Object.keys(supportedNamespaces).forEach((namespace) => {\n    const supportedChains = supportedNamespaces[namespace].chains;\n    const supportedMethods = supportedNamespaces[namespace].methods;\n    const supportedEvents = supportedNamespaces[namespace].events;\n    const supportedAccounts = supportedNamespaces[namespace].accounts;\n\n    supportedChains.forEach((chain) => {\n      if (!supportedAccounts.some((account) => account.includes(chain))) {\n        throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);\n      }\n    });\n\n    namespaces[namespace] = {\n      chains: supportedChains,\n      methods: supportedMethods,\n      events: supportedEvents,\n      accounts: supportedAccounts,\n    };\n  });\n\n  // verify all required namespaces are supported\n  const err = isConformingNamespaces(requiredNamespaces, namespaces, \"approve()\");\n  if (err) throw new Error(err.message);\n\n  const approvedNamespaces = {};\n\n  // if both required & optional namespaces are empty, return all supported namespaces by the wallet\n  if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)\n    return namespaces;\n\n  // assign accounts for the required namespaces\n  Object.keys(normalizedRequired).forEach((requiredNamespace) => {\n    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>\n      normalizedRequired[requiredNamespace]?.chains?.includes(chain),\n    );\n    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>\n      normalizedRequired[requiredNamespace]?.methods?.includes(method),\n    );\n    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>\n      normalizedRequired[requiredNamespace]?.events?.includes(event),\n    );\n\n    const accounts = chains\n      .map((chain: string) =>\n        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[requiredNamespace] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  });\n\n  // add optional namespaces\n  Object.keys(normalizedOptional).forEach((optionalNamespace) => {\n    if (!supportedNamespaces[optionalNamespace]) return;\n\n    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>\n      supportedNamespaces[optionalNamespace].chains.includes(chain),\n    );\n    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>\n      normalizedOptional[optionalNamespace]?.methods?.includes(method),\n    );\n    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>\n      normalizedOptional[optionalNamespace]?.events?.includes(event),\n    );\n\n    const accountsToAdd = chainsToAdd\n      ?.map((chain: string) =>\n        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[optionalNamespace] = {\n      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),\n      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),\n      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),\n      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),\n    };\n  });\n\n  return approvedNamespaces;\n}\n\nexport function isCaipNamespace(namespace: string): boolean {\n  return namespace.includes(\":\");\n}\n\nexport function parseNamespaceKey(namespace: string) {\n  return isCaipNamespace(namespace) ? namespace.split(\":\")[0] : namespace;\n}\n\n/**\n * Converts\n * ```\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * ```\n * into\n * ```\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *```\n */\nexport function normalizeNamespaces(\n  namespaces: ProposalTypes.RequiredNamespaces,\n): ProposalTypes.RequiredNamespaces {\n  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n  }\n  return normalizedNamespaces;\n}\n","/**\n * Types\n */\nexport type SdkErrorKey = keyof typeof SDK_ERRORS;\nexport type InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nexport const SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nexport const INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { hasOverlap } from \"./misc\";\nimport { getChainsFromNamespace } from \"./caip\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  if (isValidString(value, false)) {\n    try {\n      const url = new URL(value);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n\n  if (isValidArray(chains) && chains.length) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else if (!isValidChainId(key)) {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} ${type}`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method, type);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n","import { getEnvironment, ENV_MAP, isBrowser, isReactNative } from \"./misc\";\n\nexport function isOnline(): Promise<boolean> {\n  const env = getEnvironment();\n  return new Promise((resolve) => {\n    switch (env) {\n      case ENV_MAP.browser:\n        resolve(getBrowserOnlineStatus());\n        break;\n      case ENV_MAP.reactNative:\n        resolve(getReactNativeOnlineStatus());\n        break;\n      case ENV_MAP.node:\n        resolve(getNodeOnlineStatus());\n        break;\n      default:\n        resolve(true);\n    }\n  });\n}\n\nexport function getBrowserOnlineStatus() {\n  return isBrowser() && navigator?.onLine;\n}\n\nexport async function getReactNativeOnlineStatus(): Promise<boolean> {\n  // global.NetInfo is set in react-native-compat\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    const state = await (global as any)?.NetInfo.fetch();\n    return state?.isConnected;\n  }\n  // fallback to true if global.NetInfo is undefined, meaning an older version of react-native-compat is used\n  return true;\n}\n\nexport function getNodeOnlineStatus() {\n  /**\n   * TODO: need to implement\n   */\n  return true;\n}\n\nexport function subscribeToNetworkChange(callbackHandler: (connected: boolean) => void) {\n  const env = getEnvironment();\n  switch (env) {\n    case ENV_MAP.browser:\n      subscribeToBrowserNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.reactNative:\n      subscribeToReactNativeNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.node:\n      // wip: need to implement\n      break;\n    default:\n      break;\n  }\n}\n\nexport function subscribeToBrowserNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (!isReactNative() && isBrowser()) {\n    window.addEventListener(\"online\", () => callbackHandler(true));\n    window.addEventListener(\"offline\", () => callbackHandler(false));\n  }\n}\n\n// global.NetInfo is set in react-native-compat\nexport function subscribeToReactNativeNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    (global as any)?.NetInfo.addEventListener((state: any) => callbackHandler(state?.isConnected));\n  }\n}\n","const memoryStore = {};\n\nexport abstract class MemoryStore {\n  static get<T = unknown>(key: string) {\n    return memoryStore[key] as T | undefined;\n  }\n\n  static set(key: string, value: unknown) {\n    memoryStore[key] = value;\n  }\n\n  static delete(key: string) {\n    delete memoryStore[key];\n  }\n}\n"],"names":["CAIP_DELIMITER","chain","namespace","reference","params","account","address","array","parser","unique","str","value","accounts","namespaces","keys","key","ns","chains","requiredNamespaces","namespaceProps","iss","segments","cacao","header","walletAddress","statement","uri","version","chainId","nonce","issuedAt","resources","resource","val","ZERO_INDEX","TYPE_LENGTH","IV_LENGTH","KEY_LENGTH","keyPair","x25519","toString","random","randomBytes","privateKeyA","publicKeyB","sharedKey","fromString","symKey","HKDF","SHA256","result","hash","message","type","byte","senderPublicKey","iv","sealed","ChaCha20Poly1305","box","concat","encoded","bytes","slice1","slice2","slice3","opts","deserialized","g","l","u","getDocument","getNavigator","_a","e","queryString","newQueryParams","queryParams","qs","__spreadValues","getWindowMetadata","protocol","env","metadata","getLocation","OS","Version","info","detect","os","sdkVersion","id","relayUrl","auth","projectId","useOnCloseEvent","bundleId","splitUrl","ua","url","domain","obj","context","depth","a","b","x","arr","map","cb","res","word","c","w","expiry","FIVE_MINUTES","expireErrorMessage","timeout","toMiliseconds","cacheResolve","cacheReject","cacheTimeout","promiseResolve","promiseReject","promise","resolve","reject","error","topic","target","parsed","ttl","now","fromMiliseconds","event","wcDeepLink","json","deeplink","link","err","store","deepLink","jsonrpc","RELAY_JSONRPC","delimiter","relay","prefix","name","pathStart","pathEnd","requiredValues","k","__spreadProps","R","S","methods","events","caller","validNamespacesError","isValidNamespaces","required","values","optionalNamespaces","supportedNamespaces","normalizedRequired","normalizedOptional","supportedChains","supportedMethods","supportedEvents","supportedAccounts","isConformingNamespaces","approvedNamespaces","requiredNamespace","_b","method","optionalNamespace","_c","_d","_e","_f","chainsToAdd","methodsToAdd","eventsToAdd","accountsToAdd","mergeArrays","normalizedNamespaces","isValidObject","normalizedKey","code","itemCondition","input","optional","session","sessionKeys","paramsKeys","compatible","hasOverlap","getAccountsChains","getChainsFromNamespace","split","getInternalError","valid","item","getSdkError","validChainsError","validAccountsError","validActionsError","request","response","getNamespacesChains","getNamespacesMethodsForChainId","eventName","getNamespacesEventsForChainId","parsedRequired","parseNamespaces","parsedApproved","parseApprovedNamespaces","requiredChains","approvedChains","uniqueRequired","filterDuplicateNamespaces","uniqueApproved","missingRequiredNamespaces","boundaries","getEnvironment","ENV_MAP","isBrowser","isReactNative","state","callbackHandler","memoryStore"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}},
    {"offset": {"line": 4072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4078, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/node_modules/unstorage/drivers/utils/index.mjs","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/node_modules/unstorage/drivers/indexedb.mjs","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/indexedDb.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/localStoragePrototype.js","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/keyvaluestorage/src/shared/utils.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/localStore.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/browserMigration.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/keyvaluestorage/src/browser/index.ts"],"sourcesContent":["export function defineDriver(factory) {\n  return factory;\n}\nexport function normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.replace(/[/\\\\]/g, \":\").replace(/^:|:$/g, \"\");\n}\nexport function joinKeys(...keys) {\n  return keys.map(normalizeKey).filter(Boolean).join(\":\");\n}\nexport function createError(driver, message, opts) {\n  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);\n  return err;\n}\nexport function createRequiredError(driver, name) {\n  if (Array.isArray(name)) {\n    return createError(\n      driver,\n      `Missing some of the required options ${name.map((n) => \"`\" + n + \"`\").join(\", \")}`\n    );\n  }\n  return createError(driver, `Missing required option \\`${name}\\`.`);\n}\n","import { defineDriver } from \"./utils/index.mjs\";\nimport {\n  get,\n  set,\n  clear,\n  del,\n  keys,\n  createStore\n} from \"idb-keyval\";\nconst DRIVER_NAME = \"idb-keyval\";\nexport default defineDriver((opts = {}) => {\n  const base = opts.base && opts.base.length > 0 ? `${opts.base}:` : \"\";\n  const makeKey = (key) => base + key;\n  let customStore;\n  if (opts.dbName && opts.storeName) {\n    customStore = createStore(opts.dbName, opts.storeName);\n  }\n  return {\n    name: DRIVER_NAME,\n    options: opts,\n    async hasItem(key) {\n      const item = await get(makeKey(key), customStore);\n      return typeof item === \"undefined\" ? false : true;\n    },\n    async getItem(key) {\n      const item = await get(makeKey(key), customStore);\n      return item ?? null;\n    },\n    setItem(key, value) {\n      return set(makeKey(key), value, customStore);\n    },\n    removeItem(key) {\n      return del(makeKey(key), customStore);\n    },\n    getKeys() {\n      return keys(customStore);\n    },\n    clear() {\n      return clear(customStore);\n    }\n  };\n});\n","import { createStorage } from \"unstorage\";\nimport indexedDbDriver from \"unstorage/drivers/indexedb\";\n\nimport { IKeyValueStorage } from \"../../shared\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nconst DB_NAME = \"WALLET_CONNECT_V2_INDEXED_DB\";\nconst DB_STORE_NAME = \"keyvaluestorage\";\n\nexport class IndexedDb implements IKeyValueStorage {\n  private indexedDb;\n  constructor() {\n    this.indexedDb = createStorage({\n      driver: indexedDbDriver({ dbName: DB_NAME, storeName: DB_STORE_NAME }),\n    });\n  }\n\n  public async getKeys(): Promise<string[]> {\n    return this.indexedDb.getKeys();\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    const entries = await this.indexedDb.getItems(await this.indexedDb.getKeys());\n    return entries.map((item: any) => [item.key, item.value] as [string, T]);\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    const item = await this.indexedDb.getItem(key);\n    if (item === null) {\n      return undefined;\n    }\n    return item as T;\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    await this.indexedDb.setItem(key, safeJsonStringify(value));\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    await this.indexedDb.removeItem(key);\n  }\n}\n","/**\n * Source: https://git.coolaj86.com/coolaj86/local-storage.js/src/branch/local-storage/lib/localStorage.js\n */\n\n/* eslint-disable */\n\n(function () {\n  \"use strict\";\n\n  let db;\n\n  function LocalStorage() {}\n  db = LocalStorage;\n\n  db.prototype.getItem = function (key) {\n    if (this.hasOwnProperty(key)) {\n      return String(this[key]);\n    }\n    return null;\n  };\n\n  db.prototype.setItem = function (key, val) {\n    this[key] = String(val);\n  };\n\n  db.prototype.removeItem = function (key) {\n    delete this[key];\n  };\n\n  db.prototype.clear = function () {\n    const self = this;\n    Object.keys(self).forEach(function (key) {\n      self[key] = undefined;\n      delete self[key];\n    });\n  };\n\n  db.prototype.key = function (i) {\n    i = i || 0;\n    return Object.keys(this)[i];\n  };\n\n  db.prototype.__defineGetter__(\"length\", function () {\n    return Object.keys(this).length;\n  });\n\n  if (typeof global !== \"undefined\" && global.localStorage) {\n    module.exports = global.localStorage;\n  } else if (typeof window !== \"undefined\" && window.localStorage) {\n    module.exports = window.localStorage;\n  } else {\n    module.exports = new LocalStorage();\n  }\n})();\n","import { safeJsonParse } from \"@walletconnect/safe-json\";\n\nexport function parseEntry(entry: [string, string | null]): [string, any] {\n  return [entry[0], safeJsonParse(entry[1] ?? \"\")];\n}\n","import { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\n// @ts-expect-error\nimport localStorage from \"./localStoragePrototype\";\nimport { IKeyValueStorage, parseEntry } from \"../../shared\";\n\nexport class LocalStore implements IKeyValueStorage {\n  private readonly localStorage: Storage = localStorage;\n\n  public async getKeys(): Promise<string[]> {\n    return Object.keys(this.localStorage);\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    return Object.entries(this.localStorage).map(parseEntry);\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    const item = this.localStorage.getItem(key);\n    if (item === null) {\n      return undefined;\n    }\n    return safeJsonParse(item) as T;\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    this.localStorage.setItem(key, safeJsonStringify(value));\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    this.localStorage.removeItem(key);\n  }\n}\n","import { IKeyValueStorage } from \"../../shared\";\n\nconst VERSION_KEY = \"wc_storage_version\";\nconst DB_VERSION = 1;\n\nexport const migrate = async (\n  fromStore: IKeyValueStorage,\n  toStore: IKeyValueStorage,\n  callback: (store: IKeyValueStorage) => void,\n) => {\n  const versionKey = VERSION_KEY;\n  const currentVersion = await toStore.getItem<number>(versionKey);\n  if (currentVersion && currentVersion >= DB_VERSION) {\n    callback(toStore);\n    return;\n  }\n  const keys = await fromStore.getKeys();\n  if (!keys.length) {\n    callback(toStore);\n    return;\n  }\n  const keysToCleanup: string[] = [];\n  while (keys.length) {\n    const key = keys.shift();\n    if (!key) continue;\n    const formattedKey = key.toLowerCase();\n    if (\n      formattedKey.includes(\"wc@\") ||\n      formattedKey.includes(\"walletconnect\") ||\n      formattedKey.includes(\"wc_\") ||\n      formattedKey.includes(\"wallet_connect\")\n    ) {\n      const item = await fromStore.getItem(key);\n      await toStore.setItem(key, item);\n      keysToCleanup.push(key);\n    }\n  }\n\n  await toStore.setItem(versionKey, DB_VERSION);\n  callback(toStore);\n  cleanup(fromStore, keysToCleanup);\n};\n\nconst cleanup = async (store: IKeyValueStorage, keysToCleanup: string[]) => {\n  if (!keysToCleanup.length) {\n    return;\n  }\n\n  keysToCleanup.forEach(async (key: string) => {\n    await store.removeItem(key);\n  });\n};\n","import { IKeyValueStorage } from \"../shared\";\nimport { IndexedDb } from \"./lib/indexedDb\";\nimport { LocalStore } from \"./lib/localStore\";\nimport { migrate } from \"./lib/browserMigration\";\n\nexport class KeyValueStorage implements IKeyValueStorage {\n  private storage: IKeyValueStorage;\n  private initialized = false;\n\n  constructor() {\n    const local = new LocalStore();\n    this.storage = local;\n    try {\n      const indexed = new IndexedDb();\n      migrate(local, indexed, this.setInitialized);\n      // indexedDb isn't available in node env so this will throw\n    } catch (e) {\n      this.initialized = true;\n    }\n  }\n\n  private setInitialized = (store: IKeyValueStorage) => {\n    this.storage = store;\n    this.initialized = true;\n  };\n\n  public async getKeys(): Promise<string[]> {\n    await this.initialize();\n    return this.storage.getKeys();\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    await this.initialize();\n    return this.storage.getEntries();\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    await this.initialize();\n    return this.storage.getItem(key);\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    await this.initialize();\n    return this.storage.setItem(key, value);\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    await this.initialize();\n    return this.storage.removeItem(key);\n  }\n\n  private async initialize() {\n    if (this.initialized) {\n      return;\n    }\n    await new Promise<void>((resolve) => {\n      const interval = setInterval(() => {\n        if (this.initialized) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, 20);\n    });\n  }\n}\n\nexport default KeyValueStorage;\n"],"names":["DB_NAME","DB_STORE_NAME","createStorage","indexedDbDriver","item","key","value","safeJsonStringify","db","LocalStorage","val","self","i","global","localStoragePrototypeModule","entry","_a","safeJsonParse","localStorage","parseEntry","VERSION_KEY","DB_VERSION","fromStore","toStore","callback","versionKey","currentVersion","keys","keysToCleanup","formattedKey","cleanup","store","local","LocalStore","indexed","IndexedDb","migrate","e","resolve","interval"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7]}},
    {"offset": {"line": 4265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4271, "column": 0}, "map": {"version":3,"file":"events.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/events/src/events.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/events/src/events.ts"],"names":[],"mappings":";;;AAEM,MAAgB,OAAO;CAQ5B","ignoreList":[0]}},
    {"offset": {"line": 4276, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4282, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/events/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/events/src/index.ts"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 4285, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4321, "column": 0}, "map": {"version":3,"file":"heartbeat.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/src/types/heartbeat.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/heartbeat/src/types/heartbeat.ts"],"names":[],"mappings":";;;;;AAAA,MAAA,4CAAgD;AAMhD,MAAsB,UAAW,SAAQ,SAAA,OAAO;IAG9C,YAAY,IAAuB,CAAA;QACjC,KAAK,EAAE,CAAC;IACV,CAAC;CAIF;AATD,QAAA,UAAA,GAAA,WASC","ignoreList":[0]}},
    {"offset": {"line": 4333, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4338, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/src/types/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/heartbeat/src/types/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,8HAAA,SAA4B","ignoreList":[0]}},
    {"offset": {"line": 4344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4349, "column": 0}, "map": {"version":3,"file":"heartbeat.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/src/constants/heartbeat.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/heartbeat/src/constants/heartbeat.ts"],"names":[],"mappings":";;;;;AAAA,MAAA,wCAAmD;AAEtC,QAAA,kBAAkB,GAAG,OAAA,YAAY,CAAC;AAElC,QAAA,gBAAgB,GAAG;IAC9B,KAAK,EAAE,iBAAiB;CACzB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4359, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4364, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/src/constants/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/heartbeat/src/constants/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,kIAAA,SAA4B","ignoreList":[0]}},
    {"offset": {"line": 4370, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4375, "column": 0}, "map": {"version":3,"file":"heartbeat.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/src/heartbeat.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/heartbeat/src/heartbeat.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,6BAAsC;AACtC,MAAA,wCAAoD;AAEpD,MAAA,6BAAuD;AAEvD,MAAA,qCAAmE;AAEnE,MAAa,SAAU,SAAQ,QAAA,UAAU;IAYvC,YAAY,IAAuB,CAAA;QACjC,KAAK,CAAC,IAAI,CAAC,CAAC;QANP,IAAA,CAAA,MAAM,GAAG,IAAI,SAAA,YAAY,EAAE,CAAC;QAE5B,IAAA,CAAA,QAAQ,GAAG,YAAA,kBAAkB,CAAC;QAKnC,IAAI,CAAC,QAAQ,GAAG,CAAA,IAAI,KAAA,QAAJ,IAAI,KAAA,KAAA,IAAA,KAAA,IAAJ,IAAI,CAAE,QAAQ,KAAI,YAAA,kBAAkB,CAAC;IACvD,CAAC;IAdD,MAAM,CAAO,IAAI,CAAC,IAAuB,EAAA;;YACvC,MAAM,SAAS,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC;YACtC,MAAM,SAAS,CAAC,IAAI,EAAE,CAAC;YACvB,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAYY,IAAI,GAAA;;YACf,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QAC1B,CAAC;KAAA;IAEM,IAAI,GAAA;QACT,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAClC,CAAC;IAEM,EAAE,CAAC,KAAa,EAAE,QAAa,EAAA;QACpC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAClC,CAAC;IAEM,IAAI,CAAC,KAAa,EAAE,QAAa,EAAA;QACtC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACpC,CAAC;IAEM,GAAG,CAAC,KAAa,EAAE,QAAa,EAAA;QACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACnC,CAAC;IAEM,cAAc,CAAC,KAAa,EAAE,QAAa,EAAA;QAChD,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAIa,UAAU,GAAA;;YACtB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC,GAAG,CAAG,CAAD,GAAK,CAAC,KAAK,EAAE,EAAE,OAAA,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QACnF,CAAC;KAAA;IAEO,KAAK,GAAA;QACX,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAA,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAC3C,CAAC;CACF;AAlDD,QAAA,SAAA,GAAA,UAkDC","ignoreList":[0]}},
    {"offset": {"line": 4429, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4434, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/heartbeat/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/heartbeat/src/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,wHAAA,SAA4B;AAC5B,QAAA,YAAA,0HAAA,SAAwB;AACxB,QAAA,YAAA,8HAAA,SAA4B","ignoreList":[0]}},
    {"offset": {"line": 4442, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4448, "column": 0}, "map": {"version":3,"file":"constants.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-auth/src/constants.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/relay-auth/src/constants.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAIO,MAAM,eAAe,GAA4B,OAAO,CAAC;AAEzD,MAAM,eAAe,GAA4B,KAAK,CAAC;AAEvD,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B,MAAM,YAAY,GAAG,WAAW,CAAC;AAEjC,MAAM,aAAa,GAAG,MAAM,CAAC;AAE7B,MAAM,aAAa,GAAG,MAAM,CAAC;AAI7B,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B,MAAM,UAAU,GAAG,KAAK,CAAC;AAEzB,MAAM,UAAU,GAAG,KAAK,CAAC;AAIzB,MAAM,2BAA2B,GAAG,WAAW,CAAC;AAEhD,MAAM,uBAAuB,GAAG,GAAG,CAAC;AAEpC,MAAM,yBAAyB,GAAG,KAAK,CAAC;AAExC,MAAM,yBAAyB,GAAG,EAAE,CAAC;AAIrC,MAAM,oBAAoB,GAAG,EAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4478, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4484, "column": 0}, "map": {"version":3,"file":"utils.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-auth/src/utils.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/relay-auth/src/utils.ts"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4585, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4591, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-auth/src/api.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/relay-auth/src/api.ts"],"names":[],"mappings":";;;;;AAAA,OAAO,KAAK,OAAO,MAAM,oBAAoB,CAAC;AAC9C,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,qBAAqB,CAAC;AACtD,OAAO,EACL,eAAe,EACf,eAAe,EACf,oBAAoB,GACrB,MAAM,aAAa,CAAC;AAErB,OAAO,EACL,SAAS,EACT,SAAS,EACT,UAAU,EACV,SAAS,EACT,SAAS,GACV,MAAM,SAAS,CAAC;;;;;;AAEX,SAAU,eAAe,CAC7B,kKAAmB,cAAA,AAAW,+KAAC,uBAAoB,CAAC;IAEpD,OAAO,OAAO,kJAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;AAC/C,CAAC;AAEM,KAAK,UAAU,OAAO,CAC3B,GAAW,EACX,GAAW,EACX,GAAW,EACX,OAAwB,EACxB,0KAAc,kBAAA,AAAe,EAAC,IAAI,CAAC,GAAG,EAAE,CAAC;IAEzC,MAAM,MAAM,GAAG;QAAE,GAAG,EAAE,+LAAe;QAAE,GAAG,+KAAE,kBAAe;IAAA,CAAE,CAAC;IAC9D,MAAM,GAAG,gLAAG,YAAA,AAAS,EAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACzC,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IACtB,MAAM,OAAO,GAAG;QAAE,GAAG;QAAE,GAAG;QAAE,GAAG;QAAE,GAAG;QAAE,GAAG;IAAA,CAAE,CAAC;IAC5C,MAAM,IAAI,gLAAG,aAAA,AAAU,EAAC;QAAE,MAAM;QAAE,OAAO;IAAA,CAAE,CAAC,CAAC;IAC7C,MAAM,SAAS,GAAG,OAAO,kJAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACxD,oLAAO,YAAA,AAAS,EAAC;QAAE,MAAM;QAAE,OAAO;QAAE,SAAS;IAAA,CAAE,CAAC,CAAC;AACnD,CAAC;AAEM,KAAK,UAAU,SAAS,CAAC,GAAW;IACzC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,gLAAG,YAAA,AAAS,EAAC,GAAG,CAAC,CAAC;IAC5D,IAAI,MAAM,CAAC,GAAG,KAAK,+LAAe,IAAI,MAAM,CAAC,GAAG,kLAAK,kBAAe,EAAE;QACpE,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;KACjD;IACD,MAAM,SAAS,gLAAG,YAAA,AAAS,EAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACzC,OAAO,OAAO,kJAAC,MAAM,CAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;AACpD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4642, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4647, "column": 0}, "map": {"version":3,"sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-auth/dist/esm/types.js"],"sourcesContent":["//# sourceMappingURL=types.js.map"],"names":[],"mappings":"AAAA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 4648, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4654, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/relay-auth/src/index.ts"],"sourcesContent":["unable to read source [project]/node_modules/@walletconnect/relay-auth/src/index.ts"],"names":[],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 4660, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4755, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-ws-connection/src/utils.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/jsonrpc-ws-connection/src/ws.ts"],"sourcesContent":["export const resolveWebSocketImplementation = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  } else if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n    return global.WebSocket;\n  } else if (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") {\n    return window.WebSocket;\n  } else if (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\") {\n    return self.WebSocket;\n  }\n\n  return require(\"ws\");\n};\n\nexport const hasBuiltInWebSocket = () =>\n  typeof WebSocket !== \"undefined\" ||\n  (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") ||\n  (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") ||\n  (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\");\n\nexport const isBrowser = () => typeof window !== \"undefined\";\n\nexport const truncateQuery = (wssUrl: string) => wssUrl.split(\"?\")[0];\n","import { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport {\n  formatJsonRpcError,\n  IJsonRpcConnection,\n  JsonRpcPayload,\n  isReactNative,\n  isWsUrl,\n  isLocalhostUrl,\n  parseConnectionError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { truncateQuery, resolveWebSocketImplementation, hasBuiltInWebSocket } from \"./utils\";\n\n// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\n\nconst WS = resolveWebSocketImplementation();\n\nexport class WsConnection implements IJsonRpcConnection {\n  public events = new EventEmitter();\n\n  private socket: WebSocket | undefined;\n\n  private registering = false;\n\n  constructor(public url: string) {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    this.url = url;\n  }\n\n  get connected(): boolean {\n    return typeof this.socket !== \"undefined\";\n  }\n\n  get connecting(): boolean {\n    return this.registering;\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url);\n  }\n\n  public async close(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (typeof this.socket === \"undefined\") {\n        reject(new Error(\"Connection already closed\"));\n        return;\n      }\n\n      this.socket.onclose = (event) => {\n        this.onClose(event);\n        resolve();\n      };\n\n      this.socket.close();\n    });\n  }\n\n  public async send(payload: JsonRpcPayload): Promise<void> {\n    if (typeof this.socket === \"undefined\") {\n      this.socket = await this.register();\n    }\n    try {\n      this.socket.send(safeJsonStringify(payload));\n    } catch (e) {\n      this.onError(payload.id, e as Error);\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private register(url = this.url): Promise<WebSocket> {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (\n        this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n        this.events.listenerCount(\"open\") >= currentMaxListeners\n      ) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", (error) => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.socket === \"undefined\") {\n            return reject(new Error(\"WebSocket connection is missing or invalid\"));\n          }\n          resolve(this.socket);\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n\n    return new Promise((resolve, reject) => {\n      const origin = new URLSearchParams(url).get(\"origin\");\n      const opts = isReactNative()\n        ? { headers: { origin } }\n        : { rejectUnauthorized: !isLocalhostUrl(url) };\n      const socket: WebSocket = new WS(url, [], opts);\n      if (hasBuiltInWebSocket()) {\n        socket.onerror = (event: Event) => {\n          const errorEvent = event as ErrorEvent;\n          reject(this.emitError(errorEvent.error));\n        };\n      } else {\n        (socket as any).on(\"error\", (errorEvent: any) => {\n          reject(this.emitError(errorEvent));\n        });\n      }\n      socket.onopen = () => {\n        this.onOpen(socket);\n        resolve(socket);\n      };\n    });\n  }\n\n  private onOpen(socket: WebSocket) {\n    socket.onmessage = (event: MessageEvent) => this.onPayload(event);\n    socket.onclose = (event) => this.onClose(event);\n    this.socket = socket;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  private onClose(event: CloseEvent) {\n    this.socket = undefined;\n    this.registering = false;\n    this.events.emit(\"close\", event);\n  }\n\n  private onPayload(e: { data: any }) {\n    if (typeof e.data === \"undefined\") return;\n    const payload: JsonRpcPayload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  private onError(id: number, e: Error) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, truncateQuery(url), \"WS\");\n  }\n\n  private resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n\n  private emitError(errorEvent: Error) {\n    const error = this.parseError(\n      new Error(\n        errorEvent?.message || `WebSocket connection failed for host: ${truncateQuery(this.url)}`,\n      ),\n    );\n    this.events.emit(\"register_error\", error);\n    return error;\n  }\n}\n\nexport default WsConnection;\n"],"names":["wssUrl","EVENT_EMITTER_MAX_LISTENERS_DEFAULT","WS","resolveWebSocketImplementation","url","EventEmitter","isWsUrl","event","listener","resolve","reject","payload","safeJsonStringify","e","currentMaxListeners","error","origin","opts","isReactNative","isLocalhostUrl","socket","hasBuiltInWebSocket","errorEvent","safeJsonParse","id","message","formatJsonRpcError","parseConnectionError","truncateQuery"],"mappings":"","ignoreList":[0,1]}},
    {"offset": {"line": 4874, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4880, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/core.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/crypto.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/history.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/messages.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/publisher.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/relayer.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/store.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/subscriber.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/keychain.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/expirer.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/pairing.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/verify.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/core/echo.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/sign-client/client.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/core/node_modules/%40walletconnect/types/src/sign-client/engine.ts"],"sourcesContent":["import { IEvents } from \"@walletconnect/events\";\nimport { IHeartBeat } from \"@walletconnect/heartbeat\";\nimport { IKeyValueStorage, KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\n\nimport { ICrypto } from \"./crypto\";\nimport { IRelayer } from \"./relayer\";\nimport { IKeyChain } from \"./keychain\";\nimport { IJsonRpcHistory } from \"./history\";\nimport { IExpirer } from \"./expirer\";\nimport { IPairing } from \"./pairing\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { IVerify } from \"./verify\";\nimport { IEchoClient } from \"./echo\";\nexport declare namespace CoreTypes {\n  interface Options {\n    projectId?: string;\n    name?: string;\n    relayUrl?: string;\n    logger?: string | Logger;\n    keychain?: IKeyChain;\n    storage?: IKeyValueStorage;\n    storageOptions?: KeyValueStorageOptions;\n    customStoragePrefix?: string;\n  }\n\n  interface Metadata {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n    verifyUrl?: string;\n    redirect?: {\n      native?: string;\n      universal?: string;\n    };\n  }\n}\n\nexport abstract class ICore extends IEvents {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly relayUrl?: string;\n  public abstract readonly projectId?: string;\n  public abstract readonly customStoragePrefix: string;\n\n  public abstract logger: Logger;\n  public abstract heartbeat: IHeartBeat;\n  public abstract crypto: ICrypto;\n  public abstract relayer: IRelayer;\n  public abstract storage: IKeyValueStorage;\n  public abstract history: IJsonRpcHistory;\n  public abstract expirer: IExpirer;\n  public abstract pairing: IPairing;\n  public abstract verify: IVerify;\n  public abstract echoClient: IEchoClient;\n\n  constructor(public opts?: CoreTypes.Options) {\n    super();\n  }\n\n  public abstract start(): Promise<void>;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string): number;\n  public abstract getPayloadSenderPublicKey(encoded: string): string | undefined;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport interface JsonRpcRecord {\n  id: number;\n  topic: string;\n  request: RequestArguments;\n  chainId?: string;\n  response?: { result: any } | { error: ErrorResponse };\n  expiry?: number;\n}\n\nexport interface RequestEvent {\n  topic: string;\n  request: JsonRpcRequest;\n  chainId?: string;\n}\n\nexport abstract class IJsonRpcHistory extends IEvents {\n  public records = new Map<number, JsonRpcRecord>();\n\n  public abstract readonly context: string;\n\n  public abstract readonly size: number;\n\n  public abstract readonly keys: number[];\n\n  public abstract readonly values: JsonRpcRecord[];\n\n  public abstract readonly pending: RequestEvent[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;\n\n  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;\n\n  public abstract resolve(response: JsonRpcResponse): Promise<void>;\n\n  public abstract delete(topic: string, id?: number): void;\n\n  public abstract exists(topic: string, id: number): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, message: string): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<Required<RelayerTypes.PublishOptions>, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n  }\n\n  export interface SubscribeOptions {\n    relay: ProtocolOptions;\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n  }\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace SubscriberTypes {\n  export interface Params extends RelayerTypes.SubscribeOptions {\n    topic: string;\n  }\n\n  export interface Active extends Params {\n    id: string;\n  }\n}\n\nexport declare namespace SubscriberEvents {\n  export type Created = SubscriberTypes.Active;\n\n  export interface Deleted extends SubscriberTypes.Active {\n    reason: ErrorResponse;\n  }\n\n  export type Expired = Deleted;\n}\n\nexport abstract class ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  public abstract readonly topics: string[];\n\n  public abstract set(topic: string, id: string): void;\n\n  public abstract get(topic: string): string[];\n\n  public abstract exists(topic: string, id: string): boolean;\n\n  public abstract delete(topic: string, id?: string): void;\n\n  public abstract clear(): void;\n}\n\nexport abstract class ISubscriber extends IEvents {\n  public abstract subscriptions: Map<string, SubscriberTypes.Active>;\n\n  public abstract topicMap: ISubscriberTopicMap;\n\n  public abstract readonly length: number;\n\n  public abstract readonly ids: string[];\n\n  public abstract readonly values: SubscriberTypes.Active[];\n\n  public abstract readonly topics: string[];\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n\n  public abstract isSubscribed(topic: string): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public core: ICore, public logger: Logger) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): void;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(public projectId: string, public logger: Logger) {}\n\n  public abstract init(params?: { verifyUrl?: string }): Promise<void>;\n\n  public abstract register(params: { attestationId: string }): Promise<void>;\n\n  public abstract resolve(params: {\n    attestationId: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace EchoClientTypes {\n  type RegisterDeviceTokenParams = {\n    clientId: string;\n    token: string;\n    notificationType: \"fcm\" | \"apns\" | \"apns-sandbox\" | \"noop\";\n    enableEncrypted?: boolean;\n  };\n}\nexport abstract class IEchoClient {\n  public abstract readonly context: string;\n  constructor(public projectId: string, public logger: Logger) {}\n\n  public abstract registerDeviceToken(\n    params: EchoClientTypes.RegisterDeviceTokenParams,\n  ): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"proposal_expire\"\n    | \"session_request_expire\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n}\n","import {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client\";\nimport { RelayerTypes } from \"../core/relayer\";\nimport { SessionTypes } from \"./session\";\nimport { ProposalTypes } from \"./proposal\";\nimport { PairingTypes } from \"../core/pairing\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\nimport { EventEmitter } from \"events\";\nimport { PendingRequestTypes } from \"./pendingRequest\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: SessionTypes.Struct;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n    expiryTimestamp?: number;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n\n  interface ConnectParams {\n    requiredNamespaces?: ProposalTypes.RequiredNamespaces;\n    optionalNamespaces?: ProposalTypes.OptionalNamespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n    expiry?: number;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    res: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n\n  type EngineQueue<T> = {\n    state: \"IDLE\" | \"ACTIVE\";\n    queue: T[];\n  };\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    topic: string;\n    method: M;\n    params: JsonRpcTypes.RequestParams[M];\n    expiry?: number;\n    relayRpcId?: number;\n    clientRpcId?: number;\n    throwOnFailedPublish?: boolean;\n  }): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(args: {\n    id: number;\n    topic: string;\n    result: JsonRpcTypes.Results[M];\n    throwOnFailedPublish?: boolean;\n  }): Promise<void>;\n\n  sendError(id: number, topic: string, error: JsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): void;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;\n\n  deleteSession(params: {\n    topic: string;\n    expirerHasDeleted?: boolean;\n    id?: number;\n    emitEvent?: boolean;\n  }): Promise<void>;\n\n  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;\n\n  deletePendingSessionRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>,\n  ): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>,\n  ): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n\n  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];\n}\n"],"names":["IEvents","opts","core","logger","keychain","relayer","name","storagePrefix","projectId","EventEmmiter","EventEmitter","client"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}},
    {"offset": {"line": 4997, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5003, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/core.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/crypto.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/history.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/messages.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/publisher.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/relayer.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/store.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/subscriber.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/keychain.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/expirer.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/pairing.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/verify.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/core/echo.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/sign-client/client.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/node_modules/%40walletconnect/types/src/sign-client/engine.ts"],"sourcesContent":["import { IEvents } from \"@walletconnect/events\";\nimport { IHeartBeat } from \"@walletconnect/heartbeat\";\nimport { IKeyValueStorage, KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\n\nimport { ICrypto } from \"./crypto\";\nimport { IRelayer } from \"./relayer\";\nimport { IKeyChain } from \"./keychain\";\nimport { IJsonRpcHistory } from \"./history\";\nimport { IExpirer } from \"./expirer\";\nimport { IPairing } from \"./pairing\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { IVerify } from \"./verify\";\nimport { IEchoClient } from \"./echo\";\nexport declare namespace CoreTypes {\n  interface Options {\n    projectId?: string;\n    name?: string;\n    relayUrl?: string;\n    logger?: string | Logger;\n    keychain?: IKeyChain;\n    storage?: IKeyValueStorage;\n    storageOptions?: KeyValueStorageOptions;\n    customStoragePrefix?: string;\n  }\n\n  interface Metadata {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n    verifyUrl?: string;\n    redirect?: {\n      native?: string;\n      universal?: string;\n    };\n  }\n}\n\nexport abstract class ICore extends IEvents {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly relayUrl?: string;\n  public abstract readonly projectId?: string;\n  public abstract readonly customStoragePrefix: string;\n\n  public abstract logger: Logger;\n  public abstract heartbeat: IHeartBeat;\n  public abstract crypto: ICrypto;\n  public abstract relayer: IRelayer;\n  public abstract storage: IKeyValueStorage;\n  public abstract history: IJsonRpcHistory;\n  public abstract expirer: IExpirer;\n  public abstract pairing: IPairing;\n  public abstract verify: IVerify;\n  public abstract echoClient: IEchoClient;\n\n  constructor(public opts?: CoreTypes.Options) {\n    super();\n  }\n\n  public abstract start(): Promise<void>;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string): number;\n  public abstract getPayloadSenderPublicKey(encoded: string): string | undefined;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport interface JsonRpcRecord {\n  id: number;\n  topic: string;\n  request: RequestArguments;\n  chainId?: string;\n  response?: { result: any } | { error: ErrorResponse };\n  expiry?: number;\n}\n\nexport interface RequestEvent {\n  topic: string;\n  request: JsonRpcRequest;\n  chainId?: string;\n}\n\nexport abstract class IJsonRpcHistory extends IEvents {\n  public records = new Map<number, JsonRpcRecord>();\n\n  public abstract readonly context: string;\n\n  public abstract readonly size: number;\n\n  public abstract readonly keys: number[];\n\n  public abstract readonly values: JsonRpcRecord[];\n\n  public abstract readonly pending: RequestEvent[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;\n\n  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;\n\n  public abstract resolve(response: JsonRpcResponse): Promise<void>;\n\n  public abstract delete(topic: string, id?: number): void;\n\n  public abstract exists(topic: string, id: number): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, message: string): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<Required<RelayerTypes.PublishOptions>, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n  }\n\n  export interface SubscribeOptions {\n    relay: ProtocolOptions;\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n  }\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace SubscriberTypes {\n  export interface Params extends RelayerTypes.SubscribeOptions {\n    topic: string;\n  }\n\n  export interface Active extends Params {\n    id: string;\n  }\n}\n\nexport declare namespace SubscriberEvents {\n  export type Created = SubscriberTypes.Active;\n\n  export interface Deleted extends SubscriberTypes.Active {\n    reason: ErrorResponse;\n  }\n\n  export type Expired = Deleted;\n}\n\nexport abstract class ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  public abstract readonly topics: string[];\n\n  public abstract set(topic: string, id: string): void;\n\n  public abstract get(topic: string): string[];\n\n  public abstract exists(topic: string, id: string): boolean;\n\n  public abstract delete(topic: string, id?: string): void;\n\n  public abstract clear(): void;\n}\n\nexport abstract class ISubscriber extends IEvents {\n  public abstract subscriptions: Map<string, SubscriberTypes.Active>;\n\n  public abstract topicMap: ISubscriberTopicMap;\n\n  public abstract readonly length: number;\n\n  public abstract readonly ids: string[];\n\n  public abstract readonly values: SubscriberTypes.Active[];\n\n  public abstract readonly topics: string[];\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n\n  public abstract isSubscribed(topic: string): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public core: ICore, public logger: Logger) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): void;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(public projectId: string, public logger: Logger) {}\n\n  public abstract init(params?: { verifyUrl?: string }): Promise<void>;\n\n  public abstract register(params: { attestationId: string }): Promise<void>;\n\n  public abstract resolve(params: {\n    attestationId: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace EchoClientTypes {\n  type RegisterDeviceTokenParams = {\n    clientId: string;\n    token: string;\n    notificationType: \"fcm\" | \"apns\" | \"apns-sandbox\" | \"noop\";\n    enableEncrypted?: boolean;\n  };\n}\nexport abstract class IEchoClient {\n  public abstract readonly context: string;\n  constructor(public projectId: string, public logger: Logger) {}\n\n  public abstract registerDeviceToken(\n    params: EchoClientTypes.RegisterDeviceTokenParams,\n  ): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"proposal_expire\"\n    | \"session_request_expire\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n}\n","import {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client\";\nimport { RelayerTypes } from \"../core/relayer\";\nimport { SessionTypes } from \"./session\";\nimport { ProposalTypes } from \"./proposal\";\nimport { PairingTypes } from \"../core/pairing\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\nimport { EventEmitter } from \"events\";\nimport { PendingRequestTypes } from \"./pendingRequest\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: SessionTypes.Struct;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n    expiryTimestamp?: number;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n\n  interface ConnectParams {\n    requiredNamespaces?: ProposalTypes.RequiredNamespaces;\n    optionalNamespaces?: ProposalTypes.OptionalNamespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n    expiry?: number;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    res: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n\n  type EngineQueue<T> = {\n    state: \"IDLE\" | \"ACTIVE\";\n    queue: T[];\n  };\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    topic: string;\n    method: M;\n    params: JsonRpcTypes.RequestParams[M];\n    expiry?: number;\n    relayRpcId?: number;\n    clientRpcId?: number;\n    throwOnFailedPublish?: boolean;\n  }): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(args: {\n    id: number;\n    topic: string;\n    result: JsonRpcTypes.Results[M];\n    throwOnFailedPublish?: boolean;\n  }): Promise<void>;\n\n  sendError(id: number, topic: string, error: JsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): void;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;\n\n  deleteSession(params: {\n    topic: string;\n    expirerHasDeleted?: boolean;\n    id?: number;\n    emitEvent?: boolean;\n  }): Promise<void>;\n\n  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;\n\n  deletePendingSessionRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>,\n  ): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>,\n  ): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n\n  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];\n}\n"],"names":["IEvents","opts","core","logger","keychain","relayer","name","storagePrefix","projectId","EventEmmiter","EventEmitter","client"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}},
    {"offset": {"line": 5120, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5126, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/client.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/history.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/proposal.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/session.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/engine.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/pendingRequest.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/constants/verify.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/controllers/engine.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/controllers/proposal.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/controllers/session.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/controllers/pendingRequest.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/client.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/sign-client/src/index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.com\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n  session_request_expire: \"session_request_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, SEVEN_DAYS, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\n","import {\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isBrowser,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n  private ignoredPayloadTypes = [TYPE_1];\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  private requestQueueDelay = ONE_SECOND;\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    await this.isInitialized();\n\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n\n    if (topic) {\n      const pairing = this.client.core.pairing.pairings.get(topic);\n      active = pairing.active;\n    }\n\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      ...(sessionProperties && { sessionProperties }),\n    };\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = {\n            ...session,\n            requiredNamespaces: proposal.requiredNamespaces,\n            optionalNamespaces: proposal.optionalNamespaces,\n          };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic) {\n            await this.client.core.pairing.updateMetadata({\n              topic,\n              metadata: session.peer.metadata,\n            });\n          }\n          resolve(completeSession);\n        }\n      },\n    );\n\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const id = await this.sendRequest({\n      topic,\n      method: \"wc_sessionPropose\",\n      params: proposal,\n      throwOnFailedPublish: true,\n    });\n\n    await this.setProposal(id, { id, ...proposal });\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    await this.isInitialized();\n    return await this.client.core.pairing.pair(params);\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidApprove(params);\n\n    const { id, relayProtocol, namespaces, sessionProperties } = params;\n    const proposal = this.client.proposal.get(id);\n    let { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n    pairingTopic = pairingTopic || \"\";\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n\n    if (pairingTopic && id) {\n      await this.client.core.pairing.updateMetadata({\n        topic: pairingTopic,\n        metadata: proposer.metadata,\n      });\n      await this.sendResult<\"wc_sessionPropose\">({\n        id,\n        topic: pairingTopic,\n        result: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.pairing.activate({ topic: pairingTopic });\n    }\n\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      pairingTopic,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n    };\n    await this.client.core.relayer.subscribe(sessionTopic);\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n    };\n    await this.client.session.set(sessionTopic, session);\n    try {\n      await this.sendRequest({\n        topic: sessionTopic,\n        method: \"wc_sessionSettle\",\n        params: sessionSettle,\n        throwOnFailedPublish: true,\n      });\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () =>\n        new Promise((resolve) =>\n          setTimeout(() => resolve(this.client.session.get(sessionTopic)), 5_00),\n        ), // artificial delay to allow for the session to be processed by the peer\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidReject(params);\n    const { id, reason } = params;\n    const { pairingTopic } = this.client.proposal.get(id);\n    if (pairingTopic) {\n      await this.sendError(id, pairingTopic, reason);\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidUpdate(params);\n    const { topic, namespaces } = params;\n    const id = await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n    });\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_update\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.client.session.update(topic, { namespaces });\n\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidExtend(params);\n    const { topic } = params;\n    const id = await this.sendRequest({ topic, method: \"wc_sessionExtend\", params: {} });\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    await this.isInitialized();\n    await this.isValidRequest(params);\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const id = payloadId();\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(engineEvent(\"session_request\", id), ({ error, result }) => {\n      if (error) reject(error);\n      else resolve(result);\n    });\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId: id,\n          topic,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: {\n              ...request,\n              expiryTimestamp: calcExpiry(expiry),\n            },\n            chainId,\n          },\n          expiry,\n          throwOnFailedPublish: true,\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", { topic, request, chainId, id });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        const wcDeepLink = await getDeepLink(\n          this.client.core.storage,\n          WALLETCONNECT_DEEPLINK_CHOICE,\n        );\n        handleDeeplinkRedirect({ id, topic, wcDeepLink });\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    if (isJsonRpcResult(response)) {\n      await this.sendResult({ id, topic, result: response.result, throwOnFailedPublish: true });\n    } else if (isJsonRpcError(response)) {\n      await this.sendError(id, topic, response.error);\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidPing(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = await this.sendRequest({ topic, method: \"wc_sessionPing\", params: {} });\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    await this.sendRequest({ topic, method: \"wc_sessionEvent\", params: { event, chainId } });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    // set the requestQueue state to idle if expirer has deleted a request as trying to respond to it would result in an exception\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (this.client.session.keys.includes(topic)) {\n      await this.client.session.update(topic, { expiry });\n    }\n    this.client.core.expirer.set(topic, expiry);\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    await this.client.proposal.set(id, proposal);\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n    if (expiry) this.client.core.expirer.set(id, expiry);\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const { topic, method, params, expiry, relayRpcId, clientRpcId, throwOnFailedPublish } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n    if (isBrowser() && METHODS_TO_VERIFY.includes(method)) {\n      const hash = hashMessage(JSON.stringify(payload));\n      this.client.core.verify.register({ attestationId: hash });\n    }\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const opts = ENGINE_RPC_OPTS[method].req;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n    if (throwOnFailedPublish) {\n      opts.internal = {\n        ...opts.internal,\n        throwOnFailedPublish: true,\n      };\n      await this.client.core.relayer.publish(topic, message, opts);\n    } else {\n      this.client.core.relayer\n        .publish(topic, message, opts)\n        .catch((error) => this.client.logger.error(error));\n    }\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish } = args;\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    if (throwOnFailedPublish) {\n      opts.internal = {\n        ...opts.internal,\n        throwOnFailedPublish: true,\n      };\n      await this.client.core.relayer.publish(topic, message, opts);\n    } else {\n      this.client.core.relayer\n        .publish(topic, message, opts)\n        .catch((error) => this.client.logger.error(error));\n    }\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private async isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n\n        // messages of certain types should be ignored as they are handled by their respective SDKs\n        if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(message))) {\n          return;\n        }\n\n        const payload = await this.client.core.crypto.decode(topic, message);\n        try {\n          if (isJsonRpcRequest(payload)) {\n            this.client.core.history.set(topic, payload);\n            this.onRelayEventRequest({ topic, payload });\n          } else if (isJsonRpcResponse(payload)) {\n            await this.client.core.history.resolve(payload);\n            await this.onRelayEventResponse({ topic, payload });\n            this.client.core.history.delete(topic, payload.id);\n          } else {\n            this.onRelayEventUnknownPayload({ topic, payload });\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      },\n    );\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        this.processRequest(request);\n        // small delay to allow for any async tasks to complete\n        await new Promise((resolve) => setTimeout(resolve, 300));\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeRequest(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequest(topic, payload);\n      case \"wc_sessionEvent\":\n        return this.onSessionEventRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = { id, pairingTopic: topic, expiryTimestamp, ...params };\n      await this.setProposal(id, proposal);\n      const hash = hashMessage(JSON.stringify(payload));\n      const verifyContext = await this.getVerifyContext(hash, proposal.proposer.metadata);\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic);\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const { relay, controller, expiry, namespaces, sessionProperties, pairingTopic } =\n        payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n      };\n      await this.sendResult<\"wc_sessionSettle\">({ id: payload.id, topic, result: true });\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n      this.cleanupDuplicatePairings(session);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidUpdate({ topic, ...params });\n      await this.client.session.update(topic, { namespaces: params.namespaces });\n      await this.sendResult<\"wc_sessionUpdate\">({ id, topic, result: true });\n      this.client.events.emit(\"session_update\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return parseInt(currentId.toString().slice(0, -3)) <= parseInt(lastId.toString().slice(0, -3));\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({ id, topic, result: true });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({ id, topic, result: true });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({ id, topic, result: true }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]);\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (topic, payload) => {\n    const { id, params } = payload;\n    try {\n      this.isValidRequest({ topic, ...params });\n      const hash = hashMessage(\n        JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id)),\n      );\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext(hash, session.peer.metadata);\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n      this.addSessionRequestToSessionRequestQueue(request);\n      this.processSessionRequestQueue();\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n      this.client.events.emit(\"session_request\", request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest(\n      pairing.topic,\n      formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n        },\n        proposal.id,\n      ),\n    );\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      // await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties } = params;\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private getVerifyContext = async (hash: string, metadata: CoreTypes.Metadata) => {\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      const result = await this.client.core.verify.resolve({\n        attestationId: hash,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.info(e);\n    }\n\n    this.client.logger.info(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: ProposalTypes.SessionProperties, type: string) => {\n    Object.values(properties).forEach((property) => {\n      if (!isValidString(property, false)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must be in Record<string, string> format. Received: ${JSON.stringify(property)}`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.engine.init();\n      this.core.verify.init({ verifyUrl: this.metadata.verifyUrl });\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\nimport { Session } from \"./controllers/session\";\nexport * from \"./constants\";\n\nexport const SessionStore = Session;\nexport const SignClient = Client;\nexport default Client;\n"],"names":["THIRTY_DAYS","SEVEN_DAYS","FIVE_MINUTES","ONE_DAY","THIRTY_SECONDS","IEngine","client","ENGINE_CONTEXT","EventEmmiter","TYPE_1","ENGINE_QUEUE_STATES","ONE_SECOND","ENGINE_RPC_OPTS","toMiliseconds","params","connectParams","__spreadProps","__spreadValues","pairingTopic","requiredNamespaces","optionalNamespaces","sessionProperties","relays","topic","uri","active","newTopic","newUri","publicKey","expiry","expiryTimestamp","calcExpiry","proposal","RELAYER_DEFAULT_PROTOCOL","reject","resolve","approval","createDelayedPromise","PROPOSAL_EXPIRY_MESSAGE","engineEvent","error","session","completeSession","message","getInternalError","id","relayProtocol","namespaces","proposer","selfPublicKey","peerPublicKey","sessionTopic","getSdkError","sessionSettle","SESSION_EXPIRY","reason","acknowledged","chainId","request","payloadId","done","result","wcDeepLink","getDeepLink","WALLETCONNECT_DEEPLINK_CHOICE","handleDeeplinkRedirect","response","isJsonRpcResult","isJsonRpcError","event","isSessionCompatible","pairing","duplicates","p","_a","_b","expirerHasDeleted","emitEvent","self","e","r","pendingRequest","verifyContext","args","method","relayRpcId","clientRpcId","throwOnFailedPublish","payload","formatJsonRpcRequest","isBrowser","METHODS_TO_VERIFY","hash","hashMessage","opts","formatJsonRpcResult","record","formatJsonRpcError","sessionTopics","proposalIds","toCleanup","isExpired","reqMethod","resMethod","err","subscriptionId","relay","controller","memoryKey","lastSessionUpdateId","MemoryStore","lastId","currentId","_topic","RELAYER_EVENTS","pendingRequests","isValidParams","isUndefined","isValidRelays","isValidObject","type","validRequiredNamespacesError","isValidRequiredNamespaces","validNamespacesError","isValidNamespaces","conformingNamespacesError","isConformingNamespaces","isValidString","isValidErrorReason","isValidRelay","validControllerError","isValidController","isValidNamespacesChainId","isValidRequest","isValidNamespacesRequest","isValidRequestExpiry","SESSION_REQUEST_EXPIRY_BOUNDARIES","isValidResponse","isValidEvent","isValidNamespacesEvent","metadata","context","VERIFY_SERVER","properties","property","isJsonRpcRequest","isJsonRpcResponse","EXPIRER_EVENTS","parseExpirerTarget","PAIRING_EVENTS","isValidId","Store","core","logger","PROPOSAL_CONTEXT","SIGN_CLIENT_STORAGE_PREFIX","SESSION_CONTEXT","REQUEST_CONTEXT","val","SignClient","ISignClient","SIGN_CLIENT_PROTOCOL","SIGN_CLIENT_VERSION","SIGN_CLIENT_DEFAULT","EventEmitter","name","listener","getAppMetadata","pino","getDefaultLoggerOptions","Core","generateChildLogger","Session","Proposal","PendingRequest","Engine","getLoggerContext","Client"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}},
    {"offset": {"line": 6409, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6415, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/ethereum-provider/src/constants/values.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/ethereum-provider/src/constants/rpc.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/ethereum-provider/src/EthereumProvider.ts","file:///home/sohail/mystuff/10-Work/projects/erc20saas/frontend/node_modules/%40walletconnect/ethereum-provider/src/index.ts"],"sourcesContent":["export const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"ethereum_provider\";\nexport const STORAGE_KEY = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\nexport const RPC_URL = \"https://rpc.walletconnect.com/v1/\";\n","export const REQUIRED_METHODS = [\"eth_sendTransaction\", \"personal_sign\"];\nexport const OPTIONAL_METHODS = [\n  \"eth_accounts\",\n  \"eth_requestAccounts\",\n  \"eth_sendRawTransaction\",\n  \"eth_sign\",\n  \"eth_signTransaction\",\n  \"eth_signTypedData\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData_v4\",\n  \"eth_sendTransaction\",\n  \"personal_sign\",\n  \"wallet_switchEthereumChain\",\n  \"wallet_addEthereumChain\",\n  \"wallet_getPermissions\",\n  \"wallet_requestPermissions\",\n  \"wallet_registerOnboarding\",\n  \"wallet_watchAsset\",\n  \"wallet_scanQRCode\",\n];\nexport const REQUIRED_EVENTS = [\"chainChanged\", \"accountsChanged\"];\nexport const OPTIONAL_EVENTS = [\n  \"chainChanged\",\n  \"accountsChanged\",\n  \"message\",\n  \"disconnect\",\n  \"connect\",\n];\n","import { EventEmitter } from \"events\";\nimport { getAccountsFromNamespaces, getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport { KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\nimport {\n  IEthereumProvider as IProvider,\n  IEthereumProviderEvents,\n  ProviderAccounts,\n  RequestArguments,\n  QrModalOptions,\n} from \"./types\";\nimport { Metadata, Namespace, UniversalProvider } from \"@walletconnect/universal-provider\";\nimport { SessionTypes, SignClientTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport {\n  STORAGE_KEY,\n  REQUIRED_METHODS,\n  REQUIRED_EVENTS,\n  RPC_URL,\n  OPTIONAL_METHODS,\n  OPTIONAL_EVENTS,\n} from \"./constants\";\n\nexport type RpcMethod =\n  | \"personal_sign\"\n  | \"eth_sendTransaction\"\n  | \"eth_accounts\"\n  | \"eth_requestAccounts\"\n  | \"eth_call\"\n  | \"eth_getBalance\"\n  | \"eth_sendRawTransaction\"\n  | \"eth_sign\"\n  | \"eth_signTransaction\"\n  | \"eth_signTypedData\"\n  | \"eth_signTypedData_v3\"\n  | \"eth_signTypedData_v4\"\n  | \"wallet_switchEthereumChain\"\n  | \"wallet_addEthereumChain\"\n  | \"wallet_getPermissions\"\n  | \"wallet_requestPermissions\"\n  | \"wallet_registerOnboarding\"\n  | \"wallet_watchAsset\"\n  | \"wallet_scanQRCode\";\n\nexport type RpcEvent = \"accountsChanged\" | \"chainChanged\" | \"message\" | \"disconnect\" | \"connect\";\n\nexport interface EthereumRpcMap {\n  [chainId: string]: string;\n}\n\nexport interface SessionEvent {\n  event: { name: string; data: any };\n  chainId: string;\n}\n\nexport interface EthereumRpcConfig {\n  chains: string[];\n  optionalChains: string[];\n  methods: string[];\n  optionalMethods?: string[];\n  /**\n   * @description Events that the wallet MUST support or the connection will be rejected\n   */\n  events: string[];\n  optionalEvents?: string[];\n  rpcMap: EthereumRpcMap;\n  projectId: string;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n}\nexport interface ConnectOps {\n  chains?: number[];\n  optionalChains?: number[];\n  rpcMap?: EthereumRpcMap;\n  pairingTopic?: string;\n}\n\nexport interface IEthereumProvider extends IProvider {\n  connect(opts?: ConnectOps | undefined): Promise<void>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n  let rpcUrl: string | undefined;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n  }\n  return rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n  return Number(chains[0].split(\":\")[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n  return `0x${chainId.toString(16)}`;\n}\n\nexport type NamespacesParams = {\n  chains: EthereumRpcConfig[\"chains\"];\n  optionalChains: EthereumRpcConfig[\"optionalChains\"];\n  methods?: EthereumRpcConfig[\"methods\"];\n  optionalMethods?: EthereumRpcConfig[\"methods\"];\n  events?: EthereumRpcConfig[\"events\"];\n  rpcMap: EthereumRpcConfig[\"rpcMap\"];\n  optionalEvents?: EthereumRpcConfig[\"events\"];\n};\n\nexport function buildNamespaces(params: NamespacesParams): {\n  required?: Namespace;\n  optional?: Namespace;\n} {\n  const { chains, optionalChains, methods, optionalMethods, events, optionalEvents, rpcMap } =\n    params;\n  if (!isValidArray(chains)) {\n    throw new Error(\"Invalid chains\");\n  }\n\n  const required: Namespace = {\n    chains,\n    methods: methods || REQUIRED_METHODS,\n    events: events || REQUIRED_EVENTS,\n    rpcMap: {\n      ...(chains.length\n        ? { [getEthereumChainId(chains)]: rpcMap[getEthereumChainId(chains)] }\n        : {}),\n    },\n  };\n\n  // make a list of events and methods that require additional permissions\n  // so we know if we should to include the required chains in the optional namespace\n  const eventsRequiringPermissions = events?.filter((event) => !REQUIRED_EVENTS.includes(event));\n  const methodsRequiringPermissions = methods?.filter((event) => !REQUIRED_METHODS.includes(event));\n\n  if (\n    !optionalChains &&\n    !optionalEvents &&\n    !optionalMethods &&\n    !eventsRequiringPermissions?.length &&\n    !methodsRequiringPermissions?.length\n  ) {\n    return { required: chains.length ? required : undefined };\n  }\n\n  /*\n   * decides whether or not to include the required chains in the optional namespace\n   * use case: if there is a single chain as required but additonal methods/events as optional\n   */\n  const shouldIncludeRequiredChains =\n    (eventsRequiringPermissions?.length && methodsRequiringPermissions?.length) || !optionalChains;\n\n  const optional: Namespace = {\n    chains: [\n      ...new Set(\n        shouldIncludeRequiredChains ? required.chains.concat(optionalChains || []) : optionalChains,\n      ),\n    ],\n    methods: [\n      ...new Set(\n        required.methods.concat(optionalMethods?.length ? optionalMethods : OPTIONAL_METHODS),\n      ),\n    ],\n    events: [\n      ...new Set(required.events.concat(optionalEvents?.length ? optionalEvents : OPTIONAL_EVENTS)),\n    ],\n    rpcMap,\n  };\n\n  return {\n    required: chains.length ? required : undefined,\n    optional: optionalChains.length ? optional : undefined,\n  };\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n  | {\n      chains: ArrayOneOrMore<number>;\n      optionalChains?: number[];\n    }\n  | {\n      chains?: number[];\n      optionalChains: ArrayOneOrMore<number>;\n    };\n\nexport type EthereumProviderOptions = {\n  projectId: string;\n  /**\n   * @note Methods that your app intents to use and the peer MUST support. If the peer does not support these methods, the connection will be rejected.\n   * @default [\"eth_sendTransaction\", \"personal_sign\"]\n   */\n  methods?: string[];\n  /**\n   * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n   */\n  optionalMethods?: string[];\n  events?: string[];\n  optionalEvents?: string[];\n  rpcMap?: EthereumRpcMap;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n  disableProviderPing?: boolean;\n  relayUrl?: string;\n  storageOptions?: KeyValueStorageOptions;\n} & ChainsProps;\n\nexport class EthereumProvider implements IEthereumProvider {\n  public events = new EventEmitter();\n  public namespace = \"eip155\";\n  public accounts: string[] = [];\n  public signer: InstanceType<typeof UniversalProvider>;\n  public chainId = 1;\n  public modal?: any;\n\n  protected rpc: EthereumRpcConfig;\n  protected readonly STORAGE_KEY = STORAGE_KEY;\n\n  constructor() {\n    // assigned during initialize\n    this.signer = {} as InstanceType<typeof UniversalProvider>;\n    this.rpc = {} as EthereumRpcConfig;\n  }\n\n  static async init(opts: EthereumProviderOptions): Promise<EthereumProvider> {\n    const provider = new EthereumProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n\n  public async request<T = unknown>(args: RequestArguments, expiry?: number): Promise<T> {\n    return await this.signer.request(args, this.formatChainId(this.chainId), expiry);\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    expiry?: number,\n  ): void {\n    this.signer.sendAsync(args, callback, this.formatChainId(this.chainId), expiry);\n  }\n\n  get connected(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connected;\n  }\n\n  get connecting(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connecting;\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.session) await this.connect();\n    const accounts = await this.request({ method: \"eth_requestAccounts\" });\n    return accounts as ProviderAccounts;\n  }\n\n  public async connect(opts?: ConnectOps): Promise<void> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts(opts);\n    const { required, optional } = buildNamespaces(this.rpc);\n    try {\n      const session = await new Promise<SessionTypes.Struct | undefined>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.subscribeModal((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          await this.signer\n            .connect({\n              namespaces: {\n                ...(required && {\n                  [this.namespace]: required,\n                }),\n              },\n              ...(optional && {\n                optionalNamespaces: {\n                  [this.namespace]: optional,\n                },\n              }),\n              pairingTopic: opts?.pairingTopic,\n            })\n            .then((session) => {\n              resolve(session);\n            })\n            .catch((error: Error) => {\n              reject(new Error(error.message));\n            });\n        },\n      );\n      if (!session) return;\n\n      const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n      // if no required chains are set, use the approved accounts to fetch chainIds\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n      this.setAccounts(accounts);\n      this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      if (this.modal) this.modal.closeModal();\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (this.session) {\n      await this.signer.disconnect();\n    }\n    this.reset();\n  }\n\n  public on: IEthereumProviderEvents[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n    return this;\n  };\n\n  public once: IEthereumProviderEvents[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n    return this;\n  };\n\n  public removeListener: IEthereumProviderEvents[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n    return this;\n  };\n\n  public off: IEthereumProviderEvents[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n    return this;\n  };\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get session() {\n    return this.signer.session;\n  }\n\n  // ---------- Protected --------------------------------------------- //\n\n  protected registerEventListeners() {\n    this.signer.on(\"session_event\", (payload: SignClientTypes.EventArguments[\"session_event\"]) => {\n      const { params } = payload;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        this.accounts = this.parseAccounts(event.data);\n        this.events.emit(\"accountsChanged\", this.accounts);\n      } else if (event.name === \"chainChanged\") {\n        this.setChainId(this.formatChainId(event.data));\n      } else {\n        this.events.emit(event.name as any, event.data);\n      }\n      this.events.emit(\"session_event\", payload);\n    });\n\n    this.signer.on(\"chainChanged\", (chainId: string) => {\n      const chain = parseInt(chainId);\n      this.chainId = chain;\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    });\n\n    this.signer.on(\n      \"session_update\",\n      (payload: SignClientTypes.EventArguments[\"session_update\"]) => {\n        this.events.emit(\"session_update\", payload);\n      },\n    );\n\n    this.signer.on(\n      \"session_delete\",\n      (payload: SignClientTypes.EventArguments[\"session_delete\"]) => {\n        this.reset();\n        this.events.emit(\"session_delete\", payload);\n        this.events.emit(\"disconnect\", {\n          ...getSdkError(\"USER_DISCONNECTED\"),\n          data: payload.topic,\n          name: \"USER_DISCONNECTED\",\n        });\n      },\n    );\n\n    this.signer.on(\"display_uri\", (uri: string) => {\n      if (this.rpc.showQrModal) {\n        // to refresh the QR we have to close the modal and open it again\n        // until proper API is provided by walletconnect modal\n        this.modal?.closeModal();\n        this.modal?.openModal({ uri });\n      }\n      this.events.emit(\"display_uri\", uri);\n    });\n  }\n\n  protected switchEthereumChain(chainId: number): void {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainId.toString(16) }],\n    });\n  }\n\n  protected isCompatibleChainId(chainId: string): boolean {\n    return typeof chainId === \"string\" ? chainId.startsWith(`${this.namespace}:`) : false;\n  }\n\n  protected formatChainId(chainId: number): string {\n    return `${this.namespace}:${chainId}`;\n  }\n\n  protected parseChainId(chainId: string): number {\n    return Number(chainId.split(\":\")[1]);\n  }\n\n  protected setChainIds(chains: string[]) {\n    const compatible = chains.filter((x) => this.isCompatibleChainId(x));\n    const chainIds = compatible.map((c) => this.parseChainId(c));\n    if (chainIds.length) {\n      this.chainId = chainIds[0];\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    }\n  }\n\n  protected setChainId(chain: string) {\n    if (this.isCompatibleChainId(chain)) {\n      const chainId = this.parseChainId(chain);\n      this.chainId = chainId;\n      this.switchEthereumChain(chainId);\n    }\n  }\n\n  protected parseAccountId(account: string): { chainId: string; address: string } {\n    const [namespace, reference, address] = account.split(\":\");\n    const chainId = `${namespace}:${reference}`;\n    return { chainId, address };\n  }\n\n  protected setAccounts(accounts: string[]) {\n    this.accounts = accounts\n      .filter((x) => this.parseChainId(this.parseAccountId(x).chainId) === this.chainId)\n      .map((x) => this.parseAccountId(x).address);\n    this.events.emit(\"accountsChanged\", this.accounts);\n  }\n\n  protected getRpcConfig(opts: EthereumProviderOptions): EthereumRpcConfig {\n    const requiredChains = opts?.chains ?? [];\n    const optionalChains = opts?.optionalChains ?? [];\n    const allChains = requiredChains.concat(optionalChains);\n    if (!allChains.length)\n      throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const requiredMethods = requiredChains.length ? opts?.methods || REQUIRED_METHODS : [];\n    const requiredEvents = requiredChains.length ? opts?.events || REQUIRED_EVENTS : [];\n    const optionalMethods = opts?.optionalMethods || [];\n    const optionalEvents = opts?.optionalEvents || [];\n    const rpcMap = opts?.rpcMap || this.buildRpcMap(allChains, opts.projectId);\n    const qrModalOptions = opts?.qrModalOptions || undefined;\n    return {\n      chains: requiredChains?.map((chain) => this.formatChainId(chain)),\n      optionalChains: optionalChains.map((chain) => this.formatChainId(chain)),\n      methods: requiredMethods,\n      events: requiredEvents,\n      optionalMethods,\n      optionalEvents,\n      rpcMap,\n      showQrModal: Boolean(opts?.showQrModal),\n      qrModalOptions,\n      projectId: opts.projectId,\n      metadata: opts.metadata,\n    };\n  }\n\n  protected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n    const map: EthereumRpcMap = {};\n    chains.forEach((chain) => {\n      map[chain] = this.getRpcUrl(chain, projectId);\n    });\n    return map;\n  }\n\n  protected async initialize(opts: EthereumProviderOptions) {\n    this.rpc = this.getRpcConfig(opts);\n    this.chainId = this.rpc.chains.length\n      ? getEthereumChainId(this.rpc.chains)\n      : getEthereumChainId(this.rpc.optionalChains);\n    this.signer = await UniversalProvider.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: opts.disableProviderPing,\n      relayUrl: opts.relayUrl,\n      storageOptions: opts.storageOptions,\n    });\n    this.registerEventListeners();\n    await this.loadPersistedSession();\n    if (this.rpc.showQrModal) {\n      let WalletConnectModalClass;\n      try {\n        const { WalletConnectModal } = await import(\"@walletconnect/modal\");\n        WalletConnectModalClass = WalletConnectModal;\n      } catch {\n        throw new Error(\"To use QR modal, please install @walletconnect/modal package\");\n      }\n      if (WalletConnectModalClass) {\n        try {\n          this.modal = new WalletConnectModalClass({\n            projectId: this.rpc.projectId,\n            ...this.rpc.qrModalOptions,\n          });\n        } catch (e) {\n          this.signer.logger.error(e);\n          throw new Error(\"Could not generate WalletConnectModal Instance\");\n        }\n      }\n    }\n  }\n\n  protected loadConnectOpts(opts?: ConnectOps) {\n    if (!opts) return;\n    const { chains, optionalChains, rpcMap } = opts;\n    if (chains && isValidArray(chains)) {\n      this.rpc.chains = chains.map((chain) => this.formatChainId(chain));\n      chains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n    if (optionalChains && isValidArray(optionalChains)) {\n      this.rpc.optionalChains = [];\n      this.rpc.optionalChains = optionalChains?.map((chain) => this.formatChainId(chain));\n      optionalChains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n  }\n\n  protected getRpcUrl(chainId: number, projectId?: string): string {\n    const providedRpc = this.rpc.rpcMap?.[chainId];\n    return (\n      providedRpc ||\n      `${RPC_URL}?chainId=eip155:${chainId}&projectId=${projectId || this.rpc.projectId}`\n    );\n  }\n\n  protected async loadPersistedSession() {\n    if (!this.session) return;\n    const chainId = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);\n\n    // cater to both inline & nested namespace formats\n    const namespace = this.session.namespaces[`${this.namespace}:${chainId}`]\n      ? this.session.namespaces[`${this.namespace}:${chainId}`]\n      : this.session.namespaces[this.namespace];\n\n    this.setChainIds(chainId ? [this.formatChainId(chainId)] : namespace?.accounts);\n    this.setAccounts(namespace?.accounts);\n  }\n\n  protected reset() {\n    this.chainId = 1;\n    this.accounts = [];\n  }\n\n  protected persist() {\n    if (!this.session) return;\n    this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n\n  protected parseAccounts(payload: string | string[]): string[] {\n    if (typeof payload === \"string\" || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map((account: string) => this.parseAccount(account));\n  }\n\n  protected parseAccount = (payload: any): string => {\n    return this.isCompatibleChainId(payload) ? this.parseAccountId(payload).address : payload;\n  };\n}\n\nexport default EthereumProvider;\n","import { EthereumProvider as Provider } from \"./EthereumProvider\";\nexport const EthereumProvider = Provider;\nexport type { EthereumProviderOptions, RpcEvent, RpcMethod } from \"./EthereumProvider\";\nexport * from \"./constants/rpc\";\nexport default Provider;\n"],"names":["chains","chainId","params","optionalChains","methods","optionalMethods","events","optionalEvents","rpcMap","isValidArray","required","REQUIRED_METHODS","REQUIRED_EVENTS","__spreadValues","eventsRequiringPermissions","event","methodsRequiringPermissions","shouldIncludeRequiredChains","optional","OPTIONAL_METHODS","OPTIONAL_EVENTS","EthereumProvider","EventEmitter","STORAGE_KEY","listener","payload","opts","provider","args","expiry","callback","session","resolve","reject","_a","state","__spreadProps","error","accounts","getAccountsFromNamespaces","chain","getSdkError","uri","_b","chainIds","x","c","account","namespace","reference","address","requiredChains","allChains","requiredMethods","requiredEvents","qrModalOptions","projectId","map","UniversalProvider","WalletConnectModalClass","WalletConnectModal","e","RPC_URL","Provider"],"mappings":"","ignoreList":[0,1,2,3]}},
    {"offset": {"line": 6723, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}