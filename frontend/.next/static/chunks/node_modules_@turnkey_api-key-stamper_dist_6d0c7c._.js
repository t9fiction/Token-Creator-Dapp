(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@turnkey_api-key-stamper_dist_6d0c7c._.js", {

"[project]/node_modules/@turnkey/api-key-stamper/dist/utils.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "convertTurnkeyApiKeyToJwk": (()=>convertTurnkeyApiKeyToJwk)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$elliptic_curves$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript)");
;
;
function convertTurnkeyApiKeyToJwk(input) {
    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;
    const jwk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$elliptic_curves$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointDecode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(compressedPublicKeyHex));
    // Ensure that d is sufficiently padded
    jwk.d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexStringToBase64url"])(uncompressedPrivateKeyHex, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_JWK_MEMBER_BYTE_LENGTH"]);
    return jwk;
}
;
 //# sourceMappingURL=utils.mjs.map
}}),
"[project]/node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "signWithApiKey": (()=>signWithApiKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turnkey/api-key-stamper/dist/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript)");
;
;
/// <reference lib="dom" />
const signWithApiKey = async (input)=>{
    const { content, publicKey, privateKey } = input;
    const key = await importTurnkeyApiKey({
        uncompressedPrivateKeyHex: privateKey,
        compressedPublicKeyHex: publicKey
    });
    return await signMessage({
        key,
        content
    });
};
async function importTurnkeyApiKey(input) {
    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;
    const jwk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertTurnkeyApiKeyToJwk"])({
        uncompressedPrivateKeyHex,
        compressedPublicKeyHex
    });
    return await crypto.subtle.importKey("jwk", jwk, {
        name: "ECDSA",
        namedCurve: "P-256"
    }, false, [
        "sign"
    ] // allow signing
    );
}
async function signMessage(input) {
    const { key, content } = input;
    const signatureIeee1363 = await crypto.subtle.sign({
        name: "ECDSA",
        hash: "SHA-256"
    }, key, new TextEncoder().encode(content));
    const signatureDer = convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(signatureDer);
}
/**
 * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:
 * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa
 *
 * Turnkey expects the signature encoding to be DER-encoded ASN.1:
 * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149
 *
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114
 *
 * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.
 *
 * @param ieee the ECDSA signature in IEEE encoding
 * @return ECDSA signature in DER encoding
 */ function convertEcdsaIeee1363ToDer(ieee) {
    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
        throw new Error("Invalid IEEE P1363 signature encoding. Length: " + ieee.length);
    }
    const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));
    const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));
    let offset = 0;
    const length = 1 + 1 + r.length + 1 + 1 + s.length;
    let der;
    if (length >= 128) {
        der = new Uint8Array(length + 3);
        der[offset++] = 48;
        der[offset++] = 128 + 1;
        der[offset++] = length;
    } else {
        der = new Uint8Array(length + 2);
        der[offset++] = 48;
        der[offset++] = length;
    }
    der[offset++] = 2;
    der[offset++] = r.length;
    der.set(r, offset);
    offset += r.length;
    der[offset++] = 2;
    der[offset++] = s.length;
    der.set(s, offset);
    return der;
}
/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311
 *
 * Transform a big integer in big endian to minimal unsigned form which has
 * no extra zero at the beginning except when the highest bit is set.
 */ function toUnsignedBigNum(bytes) {
    // Remove zero prefixes.
    let start = 0;
    while(start < bytes.length && bytes[start] == 0){
        start++;
    }
    if (start == bytes.length) {
        start = bytes.length - 1;
    }
    let extraZero = 0;
    // If the 1st bit is not zero, add 1 zero byte.
    if ((bytes[start] & 128) == 128) {
        // Add extra zero.
        extraZero = 1;
    }
    const res = new Uint8Array(bytes.length - start + extraZero);
    res.set(bytes.subarray(start), extraZero);
    return res;
}
;
 //# sourceMappingURL=webcrypto.mjs.map
}}),
}]);

//# sourceMappingURL=node_modules_%40turnkey_api-key-stamper_dist_6d0c7c._.js.map